# 4장 - 이더리움으로 진화

---

# 1. 비트코인의 제한된 기능 개선

비트코인은 스크립트 머니의 개념을 적용한 최초의 탈중앙화 합의 프로토콜. 즉, 제한된 프로그램 실행의 참/거짓 상태에 따라 암호화폐 거래가 가능하다는 것이다.

초기에는 비트코인을 화폐 정도로 봤으나, 시간이 지나면서 더 많은 가치를 가진 저장 수단으로 보기 시작했다. 화폐와 저장 수단의 두 관점 차이에서 많은 논쟁이 일어났다.

**개발자 커뮤니티와 프로토콜 변화**:

- 보안과 안전성을 최우선으로 하여, 제한적이고 신중한 프로토콜 변경을 주장함
- 블록 크기 증가와 같은 변화는 회의적인 시각으로 받아들여짐

**확장성 문제와 발전 방향**:

- 일부 개발자들은 확장성을 해결하기 위한 움직임을 보이며, 새로운 블록체인을 만드는 방법을 고안함
- 이러한 노력은 비트코인이 미래에 ‘프로그래밍이 가능한 돈’으로 발전할 수 있는 토대를 마련함

## 1.1 컬러드 코인과 토큰

컬러드 코인은 주식이나 금과 같은 실제 자산을 비트코인 블록체인에 표현하고 관리할 수 있도록 해준다.

비트코인 스크립트 언어는 사용 가능한 내장 명령어를 제한했는데, 이유는 네트워크의 복잡성을 낮추기 위함이다. 이로 인해 컬러드 코인은 비트코인 블록체인이 아닌, 비트코인 블록체인 위에 별도 레이어에 구축된다.

**데이터 저장과 메타데이터 활용**:

비트코인은 저장할 수 있는 데이터 범위가 제한적이지만, 소량의 데이터나 메타데이터 저장은 가능함

**토큰의 도입**:

- 컬러드 코인에서 토큰 개념을 도입해, 기존 블록체인 위에 독특한 원장을 프로그래밍하여 새로운 가치 단위를 만듦
- 토큰은 다른 암호화폐처럼 보이고 행동하며, 이더리움 생태계 발전에 영향을 받아 다양한 블록체인에서 토큰이 등장함

## 1.2 마스터코인과 스마트 콘트랙트

**마스터코인의 등장**:

- 2013년에 개발되어 비트코인 위에 구축됨
- 비트코인의 핵심 프로토콜에 포함되지 않은 새로운 기능을 추가함

**프로그램 가능한 돈으로의 진화**:

- 단순한 비트코인의 기능을 넘어, 스마트 콘트랙트와 같은 복잡한 프로그램 실행 개념 도입
- 이로 인해 비트코인이 프로그램 가능한 돈으로 발전하는 기반을 마련함

**토큰 개념의 도입**:

- 추가 암호화폐, 즉 토큰을 생성할 수 있는 개념을 도입함
- 마스터코인 이전에는 소프트웨어 포크 외부에서 새 암호화폐를 만드는 것이 어려웠음

**연구와 발전의 기초**:

- 비록 현재는 원시적인 상태로 평가되지만, 비트코인의 한계를 확장하고 새로운 가능성을 탐구하는 연구의 기초가 됨

## 1.3 옴니레이어의 이해

**옴니레이어의 개념 및 기원**

- 비트코인 기반의 오픈소스, 분산 자산 거래 플랫폼으로 시작됨
- 2013년 ICO로 모은 자금으로 마스터코인 재단이 시작한 마스터코인 프로젝트에서 옴니레이어로 이름이 변경됨

**옴니코어와의 관계**

- 옴니레이어는 참조 구현체인 옴니코어와 함께 진행되는 프로젝트임
- 옴니코어는 비트코인의 기본 요소를 보완하여 추가 기능을 강화함

**스마트 콘트랙트와 확장 기능**

- 스마트 콘트랙트 기능을 제공하여 개발자가 탈중앙화되고 투명한 방식으로 화폐 기능을 자동화할 수 있도록 함
- 블록체인 상에서 트랜잭션과 합의를 실행하여 통화 이외의 다양한 기능을 수행할 수 있음
- 토큰을 통해 다른 블록체인 프로토콜 위에 새로운 암호화폐를 만드는 기능도 포함됨
    
    <img width="452" alt="image" src="https://github.com/user-attachments/assets/06ec3e1f-19e8-42b0-ba43-e88f67fe057a" />


## 1.4 테더

**테더의 역할과 목적**

- 옴니레이어에서 가장 잘 알려진 프로젝트로, 암호화폐의 변동성 문제를 해결하기 위해 미국 달러에 고정된 안정적인 통화를 제공하는 것을 목표로 함

**1달러 고정 및 백서 주장**

- 테더 백서에 따르면, 테더 토큰은 1달러에 고정되어 있어 법정화폐 담보로 기능함

**실제 자산과 토큰화 문제**

- 실제 자산을 블록체인에 표현할 때 가치 평가와 증명에 문제가 발생
- 테더는 1달러 담보를 주장하지만, 모든 유통 테더에 대해 실제 은행 계좌에 1달러가 있다는 명확한 증거는 제공되지 않음

**감사 및 시장 변동성**

- 미국 달러 1:1 고정을 위한 전면적인 감사를 약속했으나, 2018년에 회계감사 법인과의 관계를 중단함
- 시장에서는 때때로 테더 가격이 1달러 이하로 하락하는 현상이 있었으나, 이후 별다른 설명 없이 회복됨

**실험적 성격과 검증 필요성**

- 테더는 옴니레이어를 활용한 토큰화의 흥미로운 초기 사용 사례이나, 여전히 실험적인 성격을 띠고 있음
- 실제 자산(미국 달러)으로 암호화폐를 보증하는 방식은 추가적인 검증과 개선이 필요한 상황임

## 1.5 옴니레이어의 작동방식

**관세(화폐 생성 기능)**

- 옴니레이어 네트워크의 원장에서 누구나 새로운 화폐를 만들 수 있는 기능을 구현함

**탈중앙화 거래소**

- 중앙집중식 거래소 대신, 트레이드 코드를 실행하여 당사자 간에 통화를 쉽게 교환할 수 있도록 지원

**강력한 채굴자 네트워크 구축**

- 작업 증명을 기반으로 한 블록체인을 출시할 때, 해시파워를 전용할 수 있는 강력한 채굴자 네트워크를 마련하여 네트워크 분산성, 신뢰성, 보안을 강화함

**두 번째 계층 프로토콜로서의 역할**

- 기존의 비트코인 네트워크 효과를 그대로 활용하면서, 별도의 부담 없이 토큰화와 스마트 콘트랙트 등의 추가 기능을 탈중앙화 블록체인에서 구현함

## 1.6 사용자 정의 논리 추가

비트코인은 블록체인을 유지하는 규칙인 논리적 연산을 수행하며 합의를 이루는 기본 개념이 작동한다는 것을 입증한다. 옴니가 비트코인 블록체인에 맞춤형 논리 연산을 추가한다.

비트코인은 OP_RETURN 필드를 추가해 비트코인 트랜잭션에 추가 데이터를 첨부할 수 있는데, 이 필드가 추가되면 모든 옴니 트랜잭션은 비트코인 트랜잭션의 OP_RETURN 필드에 레코드를 저장하기 시작한다.

아래 그림은 비트코인 블록체인에 기록된 테더 거래의 예다. USDT라고도 알려진 5개의 작은 테더 트랜잭션이다.

<img width="710" alt="image" src="https://github.com/user-attachments/assets/a4847ea2-93eb-426b-8f9b-42cbe798b77f" />


옴니 레이어는 메타데이터를 포함하는 비트코인 트랜잭션이다. 옴니 트랜잭션의 유일한 차이점은 OP_RETURN 필드의 유무다. 옴니는 충분한 공간을 제공하고 사용을 간편하게 하기 위해 OP_RETURN을 사용한다. OP_RETURN 필드의 메타 데이터는 5 USDT가 전송되는 것으로 변환된다. 아래 그림은 (위 그림에 대한) 트랜잭션 데이터다.

<img width="580" alt="image" src="https://github.com/user-attachments/assets/5b39a44f-da6b-4915-9c34-aad5aff9e8f4" />

OP_RETURN 필드 값 `6f6cI6e6900000000000000001f00001dcd6500` 은 USDT 트랜잭션을 기록하는 옴니레이어 메타 데이터다. 메타 데이터는 16진수 형식으로 암호화돼 있으며, 아래 표는 이를 ASCII 혹은 10진 형식으로 변환한다.

<img width="607" alt="image" src="https://github.com/user-attachments/assets/6d21c40e-1bc4-427b-8167-4234dab63547" />

# 2. 이더리움: 마스터코인을 한 단계 끌어올리기

이더리움은 비트코인과 마스터코인의 개념을 기반으로 하는 더 기능적이고 일반적인 연산 프로토콜이다. 

2013년 비탈릭 부테린이 처음으로 제안했다. 마스터코인 재단에 프로토콜을 변경하고 기능을 더 추가하기 위해 활동한 이후, 개빈 우드와 다른 설립자들과 함께 프로토콜을 만들기 시작함

이더리움의 목적 → 마스터코인을 한 단계 끌어올리는 것. 즉, 합의로 확보된 탈중앙화 개방형 컴퓨터 시스템을 만드는 것.

## 2.1 이더와 가스

이더리움의 계정 단위는 이더. 이더 암호화폐는 비트코인과 비슷한 방식으로 동작하며, 거래 주소 명명법이 비슷하다. 이더리움 주소는 `0x` 시퀀스로 시작한다. 블록체인은 주기적인 네트워크 혼잡을 대비한 컨펌 시간이 훨씬 빠르며, 비트코인보다 전송 메커니즘이 훨씬 빠른 것으로 알려짐

비트코인은 UTXO(지출하지 않은 거래 출력)을 사용해 계좌의 잔액을 추적한다. **이더리움은 계좌 상태의 잔액을 추적**한다. UTXO는 지폐와 동전 등 실제 현금을 가지고 있는 것과 같은 반면에, 이더리움의 접근 방식은 모든 자금이 은행 계좌에 있는 것과 같다. UTXO를 사용하면, 결제를 하고 계좌의 잔액을 계산하는 것이 훨씬 더 복잡하다.

- 비트코인 거래 과정
    - 비트코인 주소가 1 BTC 3건 받음
    - 친구에게 1.5 BTC를 보내고 싶다면, 2 BTC를 보내야 한다.
    - 1 BTC 거래 중에 2개를 쓰고, 0.5 BTC를 돌려 받는다.

위 과정이 단일 비트코인 트랜잭션에서 발생한다.

이더리움은 추가 기능을 제공한다. 비트코인과 마스터코인의 요소를 더해서 애플리케이션 기반 블록체인 트랜잭션을 만드는 것인데, 단순한 계좌 기반 송수신 이상의 기능을 제공한다는 뜻이다. 

이더리움에는 `가스`라는 계정 단위가 있다. 가스는 개발자들이 이더리움 플랫폼에서 애플리케이션들을 실행할 수 있게 한다. 
애플리케이션들은 탈중앙화 응용 프로그램 또는 디앱으로 알려져 있다.

가스는 블록체인에서 발생할 수 있는 위험 중 하나를 해결한다.

- 개발자들은 이를 통해 이더리움 상에서 디앱을 실행할 때, 정지 문제 또는 무한히 실행되거나 무한 루프에 빠지는 코드를 방지할 수 있다.
- 이더리움은 스마트 콘트랙트에서 실행되는 코드의 계산에 가스 사용을 요구해 디앱이 가능한 한 효율적으로 동작하게 한다.
- 모든 이더리움 거래에는 개발자가 가스 한도를 지정하므로, 무한 루프가 발생하면 해당 거래는 결국 가스를 모두 소진하게 되고 → 마이너는 트랜잭션을 실행 한 대가로 수수료를 받을 수 있다.

## 2.2 사용 사례: ICO

**리카르디안 계약**은 1996년 제안된 개념으로, 스마트 콘트랙트의 초기 발전에 큰 영향을 줬다.
핵심 아이디어는 **암호화 해시를 통한 계약 식별**과 **법적 요소를 기계가 판독 가능한 형태로 구조화**하여 계약을 자동 실행 가능하게 한 것이다.

이 개념을 스마트 콘트랙트와 결합하여, **법적 계약을 자동화된 명령으로 변환**하고, **블록체인 기반 회계 시스템과 연동하는데 활용**되었다.

### 2.2.1 이더리움과 스마트 콘트랙트 생태계

- **이더리움의 초기**에는 생태계가 서서히 성장했으나, 곧 **스마트 콘트랙트가 강력한 자동화 도구**임이 입증됨.
- 스마트 콘트랙트를 활용하여:
    - **자금을 안전하고 자동화된 방식으로 조달** 가능
    - 투자자에게 토큰(이더리움 기반 암호화폐)을 대가로 제공 가능
- 이 구조는 다양한 프로젝트가 **스마트 계약 기반으로 펀딩을 유치하는 구조**, 즉 **ICO(Initial Coin Offering)**의 기반이 됨.

결과적으로 이더리움은 **암호화폐 자금 조달의 표준 플랫폼**으로 성장했다.

## 2.3 탈중앙화된 자율 조직

DAO(Decentralized Autonomous Organization)는 **중앙집중형 관리 기구 없이, 스마트 콘트랙트를 기반으로 운영되는 조직**을 의미한다.

### 2.3.1 ICO와 DAO의 관계

- ICO(Initial Coin Offering)는 DAO의 **자금 조달 메커니즘**으로 활용됨.
- 투자자는 ICO에 참여해 **토큰을 구매**하고, 그 토큰은 **DAO 내 의결권** 역할을 함.
- 즉, DAO는 **투자자들이 스스로 자금 운영 방향을 결정**하는 **분산형 벤처 캐피탈 모델**이라고 볼 수 있음.

### 2.3.2 사례: The DAO 프로젝트 (2016년)

- DAO 개념이 실제로 구현된 대표적 프로젝트: **"The DAO"**
- **시작 시점**: 2016년 4월
- **기반**: 이더리움 스마트 콘트랙트
- **목표**: 모금된 자금을 기술 스타트업 등에 투자하고, 그 결정은 **토큰 소유자들의 투표**로 이뤄짐
- **성과**:
    - 약 **1만 1천 명의 투자자** 참여
    - **1억 5천 4백만 달러** 이상의 자금 조달
    - 당시 기준으로 **역대 최대 규모의 크라우드펀딩**

## 2.4 이더리움의 포크로 탄생된 이더리움 클래식

### 2.4.1 DAO 해킹 사건의 발생

- **배경**: DAO는 스마트 콘트랙트를 기반으로 자동화된 투표 및 투자 기능을 제공하는 조직이었지만, 스마트 콘트랙트 코드에 보안 결함(재귀 호출 취약성)이 있었다.
- **코드 결함**
    - 지갑에서 잔액이 빠져나갈 때, 함수 호출이 끝날 때에만 잔액을 업데이트 함
    - 만약 이 함수 호출이 끝나기 전에 빠르게 여러 번 호출하면, 동일한 자금을 계속해서 인출할 수 있는 무한 재귀 상황 발생
- **문제**
    - 버그 확인 후, 수정되기 전에 이 문제로 인해 5,000만 달러 이상의 이더를 탈취 당함
- **문제 해결의 어려움**
    - 블록체인에 불변으로 저장됐기 때문에, 이미 배포된 스마트 콘트랙트 코드를 수정할 수 없었음
    - 자금을 회수하려면 **새로운 계약을 배포하고, 복구 프로세스를 별도로 수행**해야 했음

### 2.4.2 이더리움 하드포크 분리

| 구분 | 설명 |
| --- | --- |
| **하드포크(Hard Fork)** | 블록체인의 **기존 규칙과 호환되지 않는 새 규칙**으로 체인을 갈라 새로운 체인을 생성 |
| **결정 배경** | 이더리움 재단은 **피해를 복구하기 위해 하드포크를 단행**하여 도난당한 자금을 **복구 주소로 이동**시킴 |
| **포크 일시** | 2016년 7월경 |
| **결과** | 이더리움은 두 갈래로 분리됨: |
- **이더리움 (Ethereum, ETH)** – 하드포크 수행
- **이더리움 클래식 (Ethereum Classic, ETC)** – 포크 거부 및 원본 블록체인 유지

## 2.5 기타 이더리움 포크

DAO 해킹 사건은 암호화폐 커뮤니티에 포크 개념을 알려주는 계기가 됐다. 이더리움 클래식을 만드는 것 외에도 이더리움 블록체인은 취약점 등 코드의 변화를 보완하기 위해 여러 차례 포크를 거쳤다. 이더리움 프로젝트는 포크의 필요성을 이해하고, 중요하다고 여겨지는 업그레이드가 명백해지면 포킹이 불변성의 개념을 유지하는 것보다 더 나은 대안으로 여겼다. 

# 3. 탈중앙화 애플리케이션

## 3.1 정의

- 디앱(DApp)은 **블록체인 기반의 스마트 콘트랙트**를 통해 실행되는 **분산형 애플리케이션**.
- 일반적으로 아래와 같이 구성
    - **백엔드**는 스마트 콘트랙트로 구성
    - **프론트엔드 UI**는 웹/모바일 인터페이스를 통해 사용자와 상호작용
- 전통적인 **클라이언트/서버 모델**과 유사하지만, **서버는 스마트 콘트랙트를 실행하기 위한 블록체인의 일부다.**
- **디앱**은 기본적으로 **스마트 콘트랙트 플랫폼에서 실행되는 모든 컴퓨터 프로그램**이며, **오늘날 가장 큰 플랫폼은 이더리움**이다.
- 블록체인 자체가 서버 역할을 하는거고 블록체인 위에서 실행되는 것이기 때문에, 한번 배포하면 수정이 불가능하다.
때문에, 특정 주체가 없다.

## 3.2 디앱의 특성

- 불변성
    
    불변성이란 블록체인에 게시된 후에는 중앙집중화 권한으로 코드를 변경할 수 없다는 것을 의미한다. 
    디앱은 보통 중앙집중화 시스템 에서 병목 현상이 있는 곳에서 많이 사용된다
    
    - 예를 들어, 많은 중앙집중화 애플리케이션은 검열 저항성이 없다.
    (검열 저항성: 어떤 콘텐츠나 정보가 제3자나 중앙 기관에 의해 검열되지 않는 능력)
    - 즉, 제3자가 사용자가 볼 수 있는 내용을 결정한다.
    
    디앱은 검열 저항성을 제공한다.
    

## 3.3 디앱의 개발 과제

디앱은 기존 중앙집중식 애플리케이션과는 달리 블록체인 기반에서 실행되므로, 개발 시 고려해야 할 **기술적·운영적 과제**들이 존재한다.

### **3.3.1 스마트 콘트랙트 구현의 어려움**

- **변경 불가능성**: 스마트 콘트랙트는 블록체인에 배포되면 수정이 거의 불가능
- **같은 주소로 재배포 불가**: 이더리움에서는 기존 주소에 새로운 코드를 덮어쓸 수 없음
- **업그레이드 어려움**: 업그레이드하려면 아래와 같은 절차가 필요하다.
    - 새로운 콘트랙트 배포
    - 데이터 마이그레이션 등의 복잡한 절차 필요

### 3.3.2 **테스트와 보안 감사**

- **테스트넷 사용**: 이더리움 테스트넷(Ropsten, Goerli 등)을 통해 디앱을 사전 테스트.
- **보안 감사 필수**:
    - 외부 전문 보안 감사 기관을 통한 수개월간의 검토
    - 감사 결과를 **깃허브 등에서 커뮤니티에 공개**
    - 커뮤니티의 참여로 **오픈 리뷰 방식** 활용

# 4. 이더리움에서 스마트 콘트랙트의 배치 및 실행

옴니레이어는 비트코인 위에서 디앱을 구현하려는 시도였지만, 여러 가지 **제약과 중앙집중성**이 문제였다.

- **디앱 배포의 제한**
    - 개발자가 디앱을 배포하려면 **옴니코어 개발자들에게 요청**해야 했음
    - 옴니코어는 모든 디앱이 포함된 거대한 코드베이스였고,
    - **코드 배치와 수정은 중앙에서만 가능**했음 → 탈중앙화와는 거리가 멂

- **포크의 어려움**
    - 독립적인 디앱을 만들려면 **옴니코어 전체를 포크**하거나
    - **비트코인 기반의 독자 클라이언트**를 만들어야 했는데,
    - 이는 **진입 장벽이 매우 높았음**
    
- **기술적 한계**
    - 비트코인은 **가치 저장에 최적화**되어 있음
    - **스마트 콘트랙트를 실행하기 위한 언어적/구조적 한계**가 있음
        - 제한된 스크립트 언어
        - `OP_RETURN` 필드는 **80바이트 제한** → 프로그램 로직을 담기엔 부족
    - 결과적으로 **복잡한 디앱 구현에는 부적합**

## 4.1 이더리움 가상머신

이더리움 가상머신 즉, EVM을 사용하면 개발자가 쉽게 디앱을 만들고 네트워크에서 실행할 수 있다. EVM의 목적은 두 가지다.

- 개발자가 스마트 콘트랙트를 블록체인에 도입할 수 있도록 한다.
- 마이너에게 자신이 실행하는 소프트웨어에 내장된 EVM 스마트 콘트랙트 코드를 실행하는 방법을 지시한다.

### 4.1.1 스마트 콘트랙트 작성

**주요 언어: Solidity**

- 스마트 콘트랙트는 여러 언어로 작성할 수 있으나, 가장 널리 쓰이는 언어는 **Solidity**.
- Solidity는 이더리움 스마트 콘트랙트 전용으로 설계된 **고수준 프로그래밍 언어**로, 자바스크립트와 문법이 유사함.

**개발 도구: Truffle Suite**

- **Truffle Suite**는 컨센시스(ConsenSys)에서 개발한 도구 모음으로, 다음 기능을 제공:
    - **작성 (Write)**: Solidity 코드 작성
    - **디버깅 (Debug)**: 스마트 콘트랙트 실행과정 추적
    - **배포 (Deploy)**: 이더리움 네트워크로 손쉽게 배포
    - **테스트 (Test)**: 테스트 프레임워크 내장 (JavaScript/TypeScript 기반)

Truffle 외에도 Hardhat 같은 도구도 많이 사용됨.

### 4.1.2 스마트 콘트랙트 배포

**환경: Remix IDE**

- **Remix**는 이더리움 스마트 콘트랙트를 위한 **웹 기반 개발 도구**입니다.
- 설치 필요 없이 웹사이트에서 Solidity 코드 작성, 컴파일, 배포, 디버깅이 가능

**예시코드**

```solidity
contract Mastering_Blockchain_Guestbook {
    address private owner;
    string private messagefromauthors;
    mapping (uint256 => string) private guestbookmessage;
    uint256 private bookcounter;

    function Mastering_Blockchain_Guestbook() public {
        owner = msg.sender;
        bookcounter = 0;
    }

    modifier onlyOwner() {
        require(owner == msg.sender);
        _;
    }

    function setmessagefromreader(string _messagefromreader) public {
        guestbookmessage[bookcounter] = _messagefromreader;
        bookcounter++;
    }

    function getmessagefromreader(uint256 _bookentrynumber) public view returns (string) {
        return guestbookmessage[_bookentrynumber];
    }

    function getnumberofmessagesfromreaders() public view returns (uint256) {
        return bookcounter;
    }

    function setmessagefromauthors(string _messagefromauthors) onlyOwner public {
        messagefromauthors = _messagefromauthors;
    }
}
```

**스마트 콘트랙트를 생성한 트랜잭션의 세부 정보**

<img width="712" alt="image" src="https://github.com/user-attachments/assets/69d673e2-5eb4-4ecf-8ffa-e19e2b707dcf" />

- 트랜잭션의 값은 0 이더로, 이더가 전송되지 않았음을 의미
- 거래는 블록 #5357662에 기록돼 있다.
- 이 블록을 발견한 마이너는 0.00137715 Testnet ETH(tETH)의 거래 수수료를 받는다.

이더리움 네트워크가 트랜잭션을 처리한 후 아래 그림처럼 바이트 코드 형식으로 이더리움 네트워크에 스마트 콘트랙트를 저장한다.

<img width="553" alt="image" src="https://github.com/user-attachments/assets/1e1482de-c57a-43b9-9d43-879e40856057" />

스마트 콘트랙트가 만들어지면 이더리움 주소가 주어진다. 이더리움 주소는 ETH 균형 을 유지하고 ETH를 일반 이더리움 주소처럼 전송하고 수신할 수 있다.

---

스마트 콘트랙트가 만들어지면 이더리움 주소가 주어지는 부분을 찾아봄.

**스마트 콘트랙트도 `계정`이다.**

이더리움에는 두 가지 유형의 계정 존재

| 계정 타입 | 설명 |
| --- | --- |
| **EOA** (Externally Owned Account) | 일반 지갑 주소 (사람이 소유, 예: MetaMask) |
| **CA** (Contract Account) | 스마트 콘트랙트 주소 (배포되면 자동 생성) |

즉, 스마트 콘트랙트가 배포되면, 그 자체가 하나의 **계정(주소)** 역할을 한다.

---
