# 💡 암호화폐 시스템의 공개키와 개인키

- 공개키 암호화는 수신자의 공개키로 메시지를 암호화하고, 수신자의 개인키를 사용해해서 암호를 해독하는 방식이다. (개인키로만 해독 가능하다.)
- 비트코인 지갑을 생성하면 공개키와 개인키, 비트코인 주소가 생성된다.
- 비트코인 주소: 공개키를 변환한 것으로, 자금을 받을 수 있고 다른 주소로 보낼 수 있는 지갑의 ID다.
- 개인키: 저장된 암호화폐를 잠금 해제하는 데 사용된다.
- 공개키: 비트코인 주소를 생성하는 데만 사용된다. 비트코인 주소는 공개키의 압축 버전이므로 읽기 쉽다.

![image](https://github.com/user-attachments/assets/cc37972a-964d-4974-91b6-ef2a6b58f89d)

- 사용자가 개인키를 갖고 있다면, 공개키와 페어링해 비트코인 주소를 잠금 해제할 수 있다.

![image](https://github.com/user-attachments/assets/713a2532-97b9-4cc8-b8c5-152ef01f0b53)

# 💡 UTXO 모델

- 비트코인 거래는 미지출 트랜잭션 출력 Unspent Transaction Outputs, UTXO이라는 독특한 방식을 따른다.
- 비트코인 네트워크에서는 “내가 얼마를 가지고 있는지”를 잔액으로 관리하는 것이 아니라, 내가 사용할 수 있는 UTXO들의 총합으로 보는 구조이다.

### UTXO의 동작 구조

- 비트코인에서의 거래(Transaction)는 크게 두 가지로 나눌 수 있다.
	-	Inputs (입력): 이전 트랜잭션의 출력(UTXO)을 사용하여 새로운 트랜잭션을 생성하는 부분
	-	Outputs (출력): 이번 트랜잭션을 통해 새롭게 생성되는 UTXO 목록
- A가 B에게 1 BTC를 송금한다고 할 때, 아래와 같은 흐름으로 진행된다.
1. A가 과거에 받은 여러 UTXO들을 입력(Input)으로 사용
2. 그 입력들을 사용하여, B에게 1 BTC를 보내는 출력(Output)을 만듦
3. 사용하고 남은 UTXO가 있으면, A 자신에게 다시 거스름돈(Change) 형식으로 돌려줌

### 거래 수수료의 계산

- 입력(Input) 총합 - 출력(Output) 총합 = 마이너 수수료(수수료로 소각되는 부분)
- 비트코인에서 수수료는 명시적으로 설정되지 않고, 출력보다 입력이 더 많게 설정하여 발생하는 차액이 자동으로 수수료가 산정된다.
- 예시
	-	입력: A가 보유한 UTXO 1.5 BTC
	-	출력
	-	B에게 송금: 1 BTC
	-	A에게 거스름돈: 0.49 BTC
	-	수수료: 0.01 BTC (1.5 - 1 - 0.49 = 0.01)
  - 이 0.01 BTC는 채굴자(Miner)의 보상으로 주어진다.
 
### 디지털 서명

- 모든 Input에는 디지털 서명이 포함된다.
- 이 디지털 서명은 해당 UTXO를 사용하기 위해 필요한 조건으로, UTXO의 소유자(=프라이빗 키를 가진 사람)만이 이 서명을 생성할 수 있다.
- 쉽게 말하면, A가 B에게 송금할 때 A의 프라이빗 키로 Input의 디지털 서명을 해야만 네트워크에서 유효한 거래로 인정받게 된다.

# 💡 트랜잭션

- 암호화폐에서 트랜잭션은 한 주소에서 다른 주소로의 값 이동을 나타낸다. 블록체인에 게재된 트랜잭션은 ‘컨펌Confirmed됐다’고 표현한다.
- 자금의 통제권을 양도하려면 개인키로 트랜잭션에 서명해야 한다.
- 그 후, 해당 공개키는 수신자가 서명을 확인하고 트랜잭션을 검증하는 데 사용된다.
- 사용자들은 대부분의 암호화폐에서 트랜잭션이 성사되기 위해 네트워크에 소정의 수수료를 지불해야 한다.

![image](https://github.com/user-attachments/assets/05012ee6-0351-48fd-a38d-43c54613c7c8)

# 💡 머클루트

- 머클루트는 256 비트로 저장된 현재 블록의 모든 트랜잭션 상태를 스냅샷으로 보여줄때 사용된다. (트랜잭션 요약 해시이다!)
- 머클루트는 머클 트리(Merkle Tree)의 최상위 노드(루트 노드)를 의미한다.
- 비트코인을 포함한 대부분의 블록체인 시스템에서 트랜잭션 무결성을 보장하고, 데이터를 효율적으로 검증하기 위해 사용되는 데이터 구조이다.
- 만약 네트워크의 모든 노드가 정확히 같은 트랜잭션 목록을 갖도록 해야 한다면 각 트랜잭션을 개별적으로 비교해야 하지만 그럴 필요가 없다.
- 머클루트를 사용하면 다른 모든 노드의 머클루트와 비교하기만 하면 되기 때문이다.
- 이로써 전체 블록체인을 저장할 필요가 없는 가벼운 소프트웨어 클라이언트를 구축해 자체 트랜잭션을 검증할 수 있다.

![image](https://github.com/user-attachments/assets/1cff728f-5b60-416b-93c2-7b2da8da2b04)

### 왜 머클루트가 필요할까? 더 자세히..

- 비트코인 블록에는 수천 개의 트랜잭션이 들어갈 수 있는데, 블록 헤더에는 이 모든 트랜잭션의 해시값을 하나하나 기록하면 비효율적이다.
- 대신, 모든 트랜잭션 해시들을 머클 트리로 묶어서, 그 최상단에 하나의 값(머클루트)만 기록함으로써 효율성과 무결성을 동시에 달성한다.
- 블록 내 트랜잭션의 데이터가 변조되지 않았음을 하나의 해시 값(머클루트)으로 증명
- 즉,	블록 헤더에 가볍게 포함시켜 블록체인의 빠른 검증 가능
- 주어진 노드의 블록체인에 어떤 변조나 부패가 생긴다면, 머클루트 해시는 더 이상 다른 노드와 일치하지 않을 것이다.

# 💡 트랜잭션 서명 및 검증

- 각 트랜잭션 입력에는 보내는 주소의 소유자가 트랜잭션을 승인했다는 증거를 제공하는 서명이 포함된다.
- 서명은 개인키와 트랜잭션 데이터를 입력으로 하는 암호화 알고리듬인 ECDSA를 사용해 생성되고 암호화된다.
- 중요한 것은 트랜잭션를 허가하는 디지털 서명이 유효한지 확인하는 데 개인키는 필요하지 않다는 점이다.
- 모든 노드가 공개 정보(공개키)를 사용해 트랜잭션을 쉽게 검증할 수 있지만 개인키가 필요하기 때문에 서명 자체를 생성할 수는 없다.

# 💡 코인베이스 트랜잭션

- 모든 블록에 기록된 첫 번째 트랜잭션을 코인베이스 트랜잭션이라고 한다.
- 코인베이스 트랜잭션은 두 가지 값으로 구성된다.
  - 블록보상
  - 거래 수수료

# 💡 비트코인 트랜잭션 보안

- 푸시 트랜잭션(Push Transaction)은 송금자가 자금을 능동적으로 보내는 구조를 의미한다. 비트코인은 기본적으로 푸시 방식으로 설계되어 있다.
- 푸시 트랜잭션 -> 내가 트랜잭션을 만들어서 네트워크에 직접 “밀어 넣는(push)” 방식
	-	송금자가 직접 서명하여 트랜잭션을 전파 (브로드캐스트)
	-	상대방은 트랜잭션이 블록에 포함되고 나서야 "받는" 것
- 반대 개념 -> 풀 트랜잭션(Pull Transaction)
	-	상대방이 내 계정에서 돈을 "땡겨가는(Pull)" 방식
	-	예: 신용카드 결제, 자동이체 등
	-	상대방이 송금자의 계정에 대한 접근 권한으로 자금을 요청 (보안이 취약하다!)
-	비트코인은 송금자가 "서명된 트랜잭션"을 만들어 네트워크로 푸시하지 않으면, 누구도 자금을 이동시킬 수 없다.
-	내 지갑(프라이빗 키)에서 직접 트랜잭션을 생성하고 서명하여 네트워크에 "밀어 넣음"
-	네트워크는 서명 검증, UTXO 유효성 검증을 통해 해당 자금이 유효하게 송금된 것인지 확인
-	제3자(수신자, 수수료를 가져가는 마이너, 네트워크 등) 모두 송금자의 서명 없이는 이 자금을 사용할 수 없다.

![image](https://github.com/user-attachments/assets/edcb4d6d-f2d8-468d-b383-ba8a1c84f899)

# 💡 해시

- 암호화 해시는 어떤 형태의 데이터든 고정된 크기의 문자열로 암호화하는 함수다. 해시는 블록체인에서 다음과 같은 특성이 있다.
- 입력에 관계없이 결과 해시는 항상 고정된 길이다. 예를 들어 SHA-256에 의해 생성된 해시의 길이는 항상 256비트다.
- 해시는 단방향 암호화로 데이터를 쉽게 암호화할 수 있다.
- 반대로 해시를 원래 입력 데이터로 다시 해독하는 것은 불가능하지는 않지만 매우 어렵다. 개인키 없이 해시를 해독하는 유일한 방법은 브루트 포스를 사용하는 것이다.
- 해시는 결정적이라서 같은 입력 데이터가 입력될 때마다 결과 해시는 항상 같다. -> 데이터의 위변조를 확인하기 쉽다.

# 💡 블록 해시

- 블록 해시는 블록이 생성되는 순간에 전체 블록체인이 어떤 모습이었는지 보여주는 스냅샷이다.
- 네트워크의 모든 노드는 블록 해시를 참조해 네트워크를 보는 시각이 다른 모든 노드와 정확히 일치하는지 확인한다.
- 노드의 원장에 사소한 차이점이 하나라도 있다면, 그 해시는 상당히 다르게 보일 것이다.
- 블록 해시로 비교해 블록체인이 변조되거나 손상되는 것을 방지하는 것이다.

![image](https://github.com/user-attachments/assets/0bb86c0b-e7d9-4af0-8789-156764759f9e)

# 💡 커스터디: 개인키는 누가 갖고 있는가

## 지갑 유형 : 수탁형과 비수탁형

- 암호화폐 자체는 어떤 장치에도 물리적으로 존재하지 않으며, 지갑은 암호키와 연관된 키를 저장하기 위해서만 사용된다.
- 수탁형지갑은 신뢰할 수 있는 엔티티에 의해 제어되며 사용자는 일반적으로 웹 인터페이스를 통해 내용에 접근해야 한다.
  - 사이트는 사용자를 위한 개인키를 저장한다. 이때 사용자는 개인키 분실을 걱정하지 않아도 된다.
  - 거래소는 수탁형 지갑의 일반적인 예다.
  - 수탁형의 분명한 단점은 거래소가 파산하거나 자금을 가지고 도망칠 경우 사용자가 키를 직접 소유하거나 통제하지 않기 때문에 할 수 있는 조치가 없다는 것이다. -> 신뢰의 문제
- 비수탁형 지갑은 사용자에게 열쇠를 완전히 제어할 수 있게 해 준다. 
  - 사용자는 개인키의 보안에 전적으로 책임이 있다.
  - 사용자가 열쇠를 잃으면, 사용자 자신도 자금에 접근할 수 없게 된다.
  - 이런 이유로 비수탁형 지갑 사용자는 보통 니모닉(복구 구문)을 백업하거나 하드웨어 월렛 같은 보안장치를 병행한다.
 
# 💡 지갑 유형 변형

- `핫 월렛`: 인터넷에 연결돼 있어 거래를 생성할 때 키를 쉽게 사용할 수 있다. 자금 이동이 쉽다는 의미다. 교환용 지갑, 웹 지갑 등 많은 커스텀 다이얼 지갑이 핫월렛이다.
- `콜드 월렛`: 개인키가 완전히 오프라인으로 저장되는 지갑이다. 이것은 종이 조각이나 인터넷과 완전히 분리된 다른 물체에 있을 수 있다. 대형 암호화폐 업체들은 안전한 보관을 위해 자금 대부분을 콜드 월렛에 보관한다.
- `하드웨어 지갑`: 개별 사용자에게 자금을 콜드 월렛으로 보관할 수 있게 해 준다. 하드웨어 지갑 장치는 인터넷에 지속적으로 연결되지 않는 비수탁형 지갑으로 암호화된 키의 안전한 저장을 보장한다.
- `웹 월렛`: 브라우저를 통해 연결되는 웹사이트 기반 지갑이다. 가령 코인베이스（수탁형）와 블록체인닷컴（비수탁형）을 말한다.
- `데스크톱 월렛`: 윈도우Windows, 맥Mac 또는 리눅스Linux 컴퓨터에서 실행되는 소프트웨어다. 비트코인은 일렉트럼이 있고, 이더리움은 메타마스크가 있다.
- `모바일 월렛`: 앱 기반 지갑으로 안드로이드나 iOS용 앱스토어에서 확인할 수 있다. 비트코인은 마이셀리움이 있고, 여러 자산을 지원하는 앱은 에지가 있다.

# 💡 복구 시드 (니모닉)

- 복구 시드는 비수탁형 지갑에 저장된 개인키를 검색하는 데 사용할 수 있는 일련의 단어다.
- 시드는 무작위 숫자와 문자열인 개인키를 기억하기가 매우 어려우므로 보통 메모리 보조 장치로 사용된다.
- 시드 문구는 일반적으로 사용자가 지갑을 되찾을 수 있도록 충분한 정보를 저장한다. 시드 구절은 다음과 같이 보이기도 한다.
- witch collapse practice feed shame open despair cr은ek road again ice least
- 복구 시드를 안다는 것 = 개인키를 안다는 것 -> 온라인 저장은 피하고, 오프라인으로 안전하게 보관할 것!

### 작동 과정

1. 지갑 생성 시 무작위 엔트로피가 생성됨 (예: 128~256 비트)
2. 이 엔트로피를 12~24개의 단어 리스트로 변환 (니모닉 구문)
3. 사용자는 이 단어들을 안전하게 백업함
4. 지갑을 복원할 때 이 니모닉을 입력하면, 동일한 개인키가 다시 생성됨 → 지갑 복구

# 💡 채굴

- 비트코인에서 채굴(mining)은 새로운 블록을 생성하고 블록체인에 추가하기 위해, 컴퓨팅 파워로 암호학적 퍼즐(Proof of Work)을 푸는 과정이다.
- 채굴의 목적은 다음과 같다.
  - 블록 생성 및 트랜잭션 검증
  - 새로운 비트코인 발행 (채굴 보상)
  - 네트워크 보안 및 합의 유지
 
### 채굴이 하는 일

1. 트랜잭션 수집 & 블록 생성
  - 비트코인 네트워크에 푸시된 트랜잭션들이 메모리풀(mempool)에 모여 있음
  -	채굴자는 이 중 일부 유효한 트랜잭션을 모아서 하나의 블록(Block)을 만듦
  -	블록에는 트랜잭션뿐만 아니라 블록 헤더가 포함됨 (블록헤더 주요 필드 - 이전 블록의 해시, 머클루트, 타임스탬프, 난이도 목표값, 논스)

2. Proof of Work 퍼즐 풀기
  - 채굴자는 논스(Nonce)라는 값을 계속 바꿔가며, 블록 헤더의 해시값이 네트워크 난이도(Difficulty) 조건을 만족하는지를 확인
  - SHA-256(SHA-256(블록 헤더)) < 네트워크가 정한 타겟 값(Difficulty Target)
  - 난이도 = 네트워크가 블록 생성 속도를 조절하기 위해 설정하는 난이도(Target 값)
  - 이게 바로 암호학적 퍼즐이다. 해시 값이 특정 수 이하가 되어야 함 → 수많은 해시를 계산하면서 맞는 값을 찾아야 함
  - 이 과정을 "해시레이트(Hashrate)를 이용한 연산 경쟁" 이라고 부름

3. 블록이 유효하면 블록체인에 추가
  - 퍼즐을 먼저 푼 채굴자가 새로운 블록을 네트워크에 브로드캐스트
  -	다른 노드들이 이 블록을 검증하고 승인하면, 블록체인에 추가됨

4. 보상 받기
  - 블록을 성공적으로 채굴한 사람은 해당 블록의 코인베이스 트랜잭션을 통해 비트코인 보상 + 트랜잭션 수수료를 얻음
  -	현재 비트코인 네트워크에서는 6.25 BTC가 보상으로 주어짐 (4년마다 반감)

### 채굴의 보안 역할

- 비트코인 네트워크를 공격자(51% 공격 등)로부터 보호
-	채굴 경쟁이 있기 때문에 블록을 마음대로 조작하거나 블록체인을 뒤집기가 매우 어려움
- 누가 블록체인을 수정하려면 막대한 해시파워(컴퓨팅 자원)를 동원해야 함 -> 비현실적으로 비용이 높음

### 정리

- 채굴자는 유효한 블록을 만들기 위해 퍼즐을 푼다. (PoW)
- 퍼즐을 푼 보상으로 비트코인 + 수수료를 얻는다.
- 이 과정으로 네트워크 보안 및 합의(Consensus)를 유지

# 💡 합의 - 작업 증명 (Proof-of-Work)

- 작업 증명은 암호화폐 트랜잭션을 확인하고 비트코인 블록체인에 블록을 넣을 수 있게 한다.
- 누구나 비트코인 네트워크에 참여해서 블록을 만들 수 있지만, 아무나 막 블록을 만들면 시스템이 망가지겠지?
- 그래서 "컴퓨터로 힘든 계산을 해낸 사람만 블록을 추가할 수 있게" 설계한 것 -> 작업 증명(Proof of Work)
- 어떻게 동작하는가?
	- 블록을 만들기 위해 컴퓨터가 무작위로 숫자(Nonce)를 조합하며 해시값을 계산
	- 이 해시값이 네트워크가 정한 목표 값(Difficulty Target) 보다 작아야 함 -> 이게 퍼즐
	- 퍼즐을 가장 먼저 푼 사람이 블록을 네트워크에 제출 -> 블록 생성 + 비트코인 보상
- 해시는 왜 쓰일까?
	- SHA-256이라는 해시 알고리즘을 사용
	-	입력 값이 살짝만 바뀌어도 전혀 다른 결과가 나오는 특징이 있어서, 맞는 해시를 찾으려면 수많은 경우를 시도해야 함
	-	그래서 "쉽게 풀 수 없는 문제"로 적합
-	여기서 해시레이트란?
	-	해시레이트(hashrate) = 컴퓨터가 1초에 몇 번 해시를 계산할 수 있는가?
	-	예: 1초에 1억 번 해시 계산 -> 100 MH/s (메가 해시)
	-	비트코인 네트워크는 이미 초당 수십~수백 EH/s (엑사 해시) 정도로 돌아가고 있음 (1 EH/s = 10^18 해시/초)

### 작업 증명의 장점

- 보안성 강화
	-	블록체인 조작을 하려면 엄청난 컴퓨팅 파워가 필요 → 공격 동기 감소
- 탈중앙화 유지
  - 누구나 퍼즐을 풀면 참여 가능 (P2P 네트워크)
- 비용이 발생
  - 퍼즐을 풀려면 컴퓨터를 돌려야 하므로 전기 비용 + 장비 비용이 들어감
  - 그래서 아무나 "공짜로 공격"하지 못함

## 마이닝 프로세스

- 마이너는 유효한 블록 해시를 생성하기 위해 다음 사항을 확인해야 한다.
	- 유효한 블록 헤더의 해시다.
	- 결과 블록 해시는 현재 네트워크 목표치보다 낮은 숫자다.

![image](https://github.com/user-attachments/assets/f38ea000-c9b8-4e1a-a11a-14bd8933ffcc)

1. 마이너가 블록을 생성할 때
	-	블록 헤더의 정보(이전 블록 해시, 머클루트, 타임스탬프 등)는 공개된 정보로 누구나 접근 가능
	-	오직 논스(Nonce) 값만 마이너가 계속 바꿔가며 퍼즐을 풂
2. 논스 조작 과정
	-	처음에는 논스 = 0으로 시작하고, 블록 헤더를 해싱하여 유효한 해시(목표 값 이하)인지 확인
	-	유효하지 않으면 논스 + 1 -> 다시 해싱 -> 계속 반복
3. 논스 오버플로 발생 시
	-	논스는 32비트(약 42억 번)까지 시도 가능
	-	다 시도했는데도 못 찾으면, 코인베이스 트랜잭션의 데이터를 미세하게 바꾸면서 추가적인 해시 공간 확보
4. 유효한 블록 해시 발견 시
	-	난이도 목표를 만족하는 해시를 찾으면 블록이 유효한 것으로 인정되고, 마이너가 새 블록을 네트워크에 브로드캐스트
5. 이 전체 과정 = 작업 증명(Proof of Work)
	-	모든 마이너가 계속 해시를 시도하는 반복 작업
	-	누가 먼저 퍼즐을 풀어서 유효한 해시를 찾느냐의 경쟁

![image](https://github.com/user-attachments/assets/6bc7eb03-ab94-448d-b710-310cc766db03)

### 트랜잭션 라이프 사이클

- 다음은 트랜잭션이 거쳐야 하는 네 가지 주요 단계다.

1. 브로드캐스트
- 사용자가 비트코인 지갑(예: 코인베이스)으로 트랜잭션을 생성
- 해당 트랜잭션은 네트워크 전체에 전파(브로드캐스트)됨
- 네트워크의 노드들이 이 트랜잭션을 수신하고 인식함

2. 멤풀(언컨펌드 상태)
- 네트워크의 노드들은 이 트랜잭션을 mempool(메모리풀)에 보관
-	mempool = 아직 블록에 포함되지 않은 대기 중인 트랜잭션들의 임시 저장소
-	트랜잭션이 블록에 포함되지 않고 2주 이상 멤풀에 남아있으면 삭제될 수 있음

3. 마이너에 의해 컨펌됨
- 마이너가 새로운 블록을 만들 때 mempool에서 수수료가 높은 트랜잭션부터 선택하여 블록에 포함
-	블록이 생성되면 블록에 포함된 트랜잭션은 1차적으로 마이너에 의해 컨펌된 상태

4. 네트워크에서 컨펌됨
- 생성된 블록이 다른 마이너들과 노드들에게도 전파되고 승인
-	이 블록 위에 다른 블록이 추가될수록 네트워크 전체가 해당 블록을 정식 블록으로 인정하게 됨
-	이때부터 네트워크 전체가 트랜잭션을 "확정된 것"으로 간주

### 컨펌

![image](https://github.com/user-attachments/assets/c9fda58a-ab42-4e8f-8e0b-68894f189baf)

-	대부분의 비트코인 지갑과 업계는 "6번 컨펌(6 confirmations)"이 되면 트랜잭션이 안전하게 확정됐다고 간주함
-	이건 네트워크 상에서 블록 위에 6개 이상의 블록이 추가로 쌓였을 때를 의미함
- 마이너가 트랜잭션을 포함한 블록을 체인에 추가하는 것이 컨펌의 시작
-	각 마이너는 독립적으로 어떤 블록을 체인에 붙일지 결정 (가장 긴 체인 우선)
- 블록 #100은 이미 3 컨펌을 받은 상태로 네트워크에 안정적으로 포함됨
-	블록 #101에서는 마이너 3명(75%)이 같은 블록을 선택했지만, 마이너 D는 다른 블록(=포크)을 붙임
- 마이너 D는 다수 마이너가 선택한 블록을 아직 모르는 상황
-	D의 블록 #101에만 포함된 트랜잭션은 결국 네트워크의 메인 블록체인에서 제외될 가능성이 높음 (D의 체인이 곧 버려질 가능성(고아 블록)이 높아짐)
- 즉, 컨펌 수가 많을수록 해당 트랜잭션이 블록체인에 안전하게 포함될 확률이 높아진다.
-	이는 네트워크가 긴 체인(다수가 선택한 체인)을 우선시하는 합의 메커니즘 때문

# 💡 합의 - 지분 증명 (Proof-of-Stake)

- PoS는 채굴(전기+장비) 없이 코인을 맡긴 사람이 네트워크를 운영하는 구조
-	PoW(채굴)는 전기 많이 먹음 -> 친환경적인 PoS가 등장
-	코인을 스테이킹하면 블록 만들 기회를 얻고, 블록을 만들면 보상을 받음
-	그냥 "돈만 맡기고 보상 받는 구조"로 보일 수 있지만, 네트워크를 안정적으로 운영할 책임이 있어서 잘못하면 스테이킹한 코인을 일부 잃음(슬래싱)
-	PoS에서 블록은 스테이킹 주체(밸리데이터) 중에서 네트워크가 뽑은 밸리데이터가 만듦
-	그냥 맡긴다고 자동으로 받는 게 아님 -> 랜덤으로 뽑혀야 블록을 만들고 보상을 받음
-	많이 맡긴 사람일수록 "뽑힐 확률"이 높음 (그래서 스테이킹 많이 한 사람은 자주 뽑혀서 꾸준히 보상을 받게 됨)
-	코인을 스테이킹한 사용자가 직접 밸리데이터 노드를 운영하거나 거래소 같은 기업이 밸리데이터 노드를 대신 운영하고, 다른 사용자들이 위임(Delegation)을 통해 참여
-	밸리터데이터 카르텔 문제? -> 밸리데이터끼리 담합하면 위협이 될 수 있지만, 현실적으로 어렵다. 매우 큰 규모의 돈이 필요하기 때문!
