# 2장. 암호화폐에 내재된 가치

- 암호화폐는 보안 및 송수신에서 주요 차이점이 있다.
    - 블록체인 시스템에서는 의지할 곳 없이 자금을 잃을 수 있다.

## 암호화폐 시스템의 공개키와 개인키

---

- 비트코인 시스템에서 공개키 암호화는 필수 요소다.
    - 비트코인 지갑을 생성하면 공개키와 개인키, 비트코인 주소가 생성된다.
    - 비트코인 주소는 공개키를 변환한 것으로, 자금을 받을 수 있고 다른 주소로 보낼 수 있는 지갑의 ID다. 공유할 수 있다.
    - 개인키는 비밀로 유지되며 저장된 암호화폐를 잠금 해제하는 데 사용된다.
        
        ![image.png](./image/image.png)
        
- 비트코인 개인키는 디지털로 거래에 서명하는 데 사용된다.
    - 비트코인 주소의 정당한 소유자임을 증명하고, 거래가 어떻게 승인되는지 증명한다.
- 비트코인 공개키는 비트코인 주소를 생성하는 데만 사용된다.
    - 비트코인 주소는 본질적으로 공개키의 압축 버전이므로 읽기가 훨씬 쉽다.

- 개인키는 무작위로 생성된 256비트 숫자다. 16진수 형식으로 표시돼 있다.
    - 개인키를 갖고 있다면, 공개키와 페어링해 비트코인 주소를 잠금 해제할 수 있다.
    - 개인키로 사용자는 공개키와 비트코인 주소를 생성할 수 있다.
        
        ![그림 2-1. 개인키에서 비트코인 주소를 찾는 과정](./image/image%201.png)
        
        그림 2-1. 개인키에서 비트코인 주소를 찾는 과정
        

## UTXO 모델

---

- 비트코인 거래는 미지출 트랜잭션 출력(UTXO, Unspent Transaction Outputs) 방식을 따른다.
- 비트코인 거래는 입력 목록과 출력 목록으로 구분된다.
    - 입력: 과거에 받은 주소와 함께 자금을 제공하는 비트코인 주소가 있는 미지출 트랜잭션을 식별한다.
        - 비트코인 주소의 소유자가 그 거래를 승인한다는 것을 증명하는 디지털 서명이 포함돼 있다.
    - 출력: 비트코인 주소와 주소가 얼마나 많은 돈을 받는지 보여준다.
    - 입력값 - 출력값: 마이너가 받게 되는 거래 수수료

![그림 2-2. 비트코인 블록 익스플로러의 모습과 샘플 트랜잭션](./image/image%202.png)

그림 2-2. 비트코인 블록 익스플로러의 모습과 샘플 트랜잭션

- 입력: 0.0128 BTC
- 출력: 0.01145732 BTC
- 입력 값 - 출력 값: 0.00134268 BTC
    - 블록체인에 블록을 발견한 마이너에게 수수료로 지급된다.

- 로우 트랜잭션의 예
    
    ```powershell
    01000000017967a5185e907a25225574544c31f7b059clal91d65b53dccl554d339c4f9efc010000006a47304402206a2ebl6b7b92051d0fa38cl33e67684ed064effadald7f925c842da401d4f22702201fl96bl0e6e4b4a9fff948e5c5d71ec5da53e90529c8dbdl22bff2bld21dc8a90121039b7bcd0824b9a9164f7ba098408e63e5b7e3cf90835ccebl9868f54f8961a825ffffffff014baf2100000000001976a914db4dli41d0048bledl5839d0b7a4c488cd368b0e88ac00000000
    ```
    
    - 구성요소
        
        
        | 항목 | 내용 |
        | --- | --- |
        | 버전 정보(Version no.) | 4바이트로 트랜잭션을 생성하는 노드가 사용하는 프로토콜 버전을 식별한다.
        현재 버전은 1이다.
        - 8자리 16진수, `01000000`(리틀 엔디언으로 저장됨), 빅 엔디언(정상적인 순서)으로 변환하면 `00000001`, 10진수 1이 된다. |
        | 플래그(Flag) | 0001 값을 나타내는 플래그가 있는 경우 노드는 트랜잭션에서 서명 정보를 제거하는 세그윗(SegWit, Segregated Witness)을 사용하고 있다는 것이다.
        - 바로 뒤에 `0001`이 존재하지 않음. 이 트랜잭션은 세그윗을 사용하지 않음. |
        | 입력 개수(In-counter) | 입력 개수
        - `01`: 1개, 입력 개수는 VarInt (Variable Integer) 방식으로 저장된다.
        • 1바이트(0x00 ~ 0xFC) → 입력 개수(1~252개)
        • 3바이트(0xFDxxxx) → 입력 개수(253~65,535개)
        • 5바이트(0xFExxxxxx) → 입력 개수(65,536~4294967295개)
        • 9바이트(0xFFxxxxxxxxxxxxxxxx) → 매우 큰 입력 개수 |
        | 입력 목록(List of inputs) | 입력된 데이터 목록
        - 트랜잭션 해시(Previous TxID): 이전 트랜잭션의 해시(32바이트, 리틀 엔디언)
        `7967a5185e907a25225574544c31f7b059c1a191d65b53dc1554d339c4f9efc`(32바이트, 리틀 엔디언), 실제 TxID: `fc9e4f9c39d35455dc53b5d6911a1c59b0f7314c547455252a790e5e18a56779`
        - 출력 인덱스(Vout, Index): 이전 트랜잭션에서 사용될 출력의 인덱스(4바이트, 리틀 엔디언)
        `01000000`(4바이트, 리틀 엔디언), `0x00000001` → 인덱스 1번 출력 사용
        - 스크립트 길이(ScriptSig Length): 스크립트 서명(ScriptSig)의 길이 (VarInt)
        `6a`(VarInt 형식, `0x6a` = 106 바이트)
        - 스크립트 서명(ScriptSig): 서명 및 공개키 포함 (가변 길이)
        1. 서명의 길이(1바이트): `47`(`0x47` = 71바이트)
        2. 서명: `304402206a2eb16b7b92051d0fa38c133e67684ed064effadad17f925c842da401d4f22702201f196b10e6e4b4a9fff948e5c5d71ec5da53e90529c8dbd122bff2b1d21dc8a90121`
        3. 공개키: `039b7bcd0824b9a9164f7ba098408e63e5b7e3cf90835cceb19868f54f8961a825`
        - 시퀀스 넘버(Sequence Number): 거래의 상대적 락타임을 설정하는 값 (4바이트)
        `ffffffff`(기본값), 타임락 기능을 활성화할 경우 다른 값이 설정됨 |
        | 출력 개수(Out-counter) | 출력된 데이터 개수
        - `01`: 1개 (1바이트, `0x01`) |
        | 출력 목록(List of outputs) | 출력된 데이터 목록
        - 출력 금액(Value): 8바이트, 리틀 엔디언
        `4baf210000000000` → `0000000021af4b`(16진수) → 2200000 사토시, 0.022 BTC
        - 스크립트 길이(ScriptPubKey Length)
        `19`(1바이트, `0x19` = 25바이트)
        - 스크립트(ScriptPubKey)
        `76a914db4dli41d0048bledl5839d0b7a4c488cd368b0e88ac`: `0x19`=25바이트, 표준 P2PKH (Pay-to-PubKey Hash) 스크립트. 수신자의 비트코인 주소에 해당하는 해시(20바이트)가 포함됨
        • 디코딩:
        `76                OP_DUP`(스택에 값 복사)
        `a9                OP_HASH160`(공개키를 RIPEMD-160 해시로 변환)
        `14                공개키 해시(PubKey Hash)의 길이`(`0x14`, 20바이트)
        `db4d...b0e        비트코인 주소의 해시`(공개키 해시)
        `88ac              OP_EQUALVERIFY OP_CHECKSIG`(서명 검증) |
        | 증인(Witnesses) | 세그윗을 사용하면 필드에는 증인 목록이 표시된다. |
        | 잠금시간(Lock time) | 4바이트로 필드가 비어 있지 않으면, 트랜잭션을 블록체인에 추가할 수 있는 가장 이른 시간을 식별한다. 이 필드는 블록 높이 또는 유닉스와 같은 타임스탬프로 표시될 수 있다.
        `00000000`: 4바이트, 0x00000000 = 0 (잠금 없음)
        • 즉, 이 트랜잭션은 즉시 유효하며, 특정 블록 높이까지 기다릴 필요 없음 |

- 기존 트랜잭션 (Legacy): 서명(Signature) 데이터가 트랜잭션 본문에 포함됨
    
    ```
    [Version] [Inputs] [Signature] [Outputs] [Locktime]
    ```
    
- 세그윗 트랜잭션 (SegWit): 서명(Signature) 데이터가 별도의 Witness 필드로 이동
    
    ```
    [Version] [Marker] [Flag] [Inputs] [Outputs] [Witness] [Locktime]
    ```
    
- cf> 세그윗
    - 비트코인의 기존 트랜잭션 구조에서는 서명 데이터가 트랜잭션 본문 안에 포함되어 있었다.
    - 문제점
        1. 블록 크기 제한 (Scalability Issue)
            - 비트코인의 블록 크기는 1MB로 제한되어 있어, 많은 트랜잭션을 포함하기 어려움
            - 트랜잭션의 약 60%가 서명 데이터였기 때문에 블록당 처리할 수 있는 트랜잭션 수가 적었음
        2. 트랜잭션 처리 속도 저하 (Transaction Throughput)
            - 블록 크기가 제한되다 보니, 많은 트랜잭션이 처리되지 못하고 네트워크 대기열에서 밀려남
            - 거래가 몰리면 수수료(Fees)가 상승하는 문제 발생
        3. 트랜잭션 가변성(Transaction Malleability)
            - 기존 방식에서는 서명(Signature) 데이터가 트랜잭션 해시에 영향을 미쳤음
            - 즉, 서명을 변경하면 트랜잭션 ID도 변경되는 문제가 발생
            - 이 문제는 2차 확장 솔루션(예: 라이트닝 네트워크) 구현을 어렵게 만듬
    - 세그윗의 해결 방법
        1. 블록 크기 확장 (실질적 4MB 증가)
            - 서명(Signature) 데이터를 별도 영역(Witness)으로 분리하여 저장
            - 기존 블록 크기 1MB 제한은 유지하되, 서명을 포함하는 새로운 세그윗 블록을 최대 4MB까지 확장 가능
            - 결과적으로 더 많은 트랜잭션을 한 블록에 포함할 수 있음
        2. 트랜잭션 처리 속도 개선
            - 서명 데이터를 제거하면서 트랜잭션 크기를 줄여 블록 내에서 더 많은 거래를 포함할 수 있음
            - 네트워크의 처리량(Throughput) 증가 → 거래 수수료 감소
        3. 트랜잭션 가변성 문제 해결
            - 트랜잭션 ID 계산 시 서명 데이터를 포함하지 않음
            - 이렇게 하면 서명을 변경하더라도 트랜잭션 ID는 변하지 않음
            - 라이트닝 네트워크 같은 2차 확장 솔루션을 구축할 수 있는 기반 마련
    
    → 현재(2024년 기준): 전체 비트코인 트랜잭션의 80% 이상이 세그윗을 사용
    
    - 수수료 절감과 속도 개선 효과로 점점 더 많은 월렛과 거래소가 세그윗을 지원

## 트랜잭션

---

- 트랜잭션: 한 주소에서 다른 주소로의 값 이동
- 컨펌(Confirmed)됐다: 블록체인에 게재된 트랜잭션
- 자금의 통제권을 양도하려면 개인키로 트랜잭션에 서명해야 한다. 그 후, 해당 공개키는 수신자가 서명을 확인하고 트랜잭션을 검증하는 데 사용된다. 사용자들은 트랜잭션이 성사되기 위해 네트워크에 소정의 수수료를 지불해야 한다.
- 수수료: 마이너들(거래가 포함된 블록을 발견)이 지속적으로 네트워크를 보호할 수 있도록 장려하기 위한 것

- 비트코인 수수료 추정기 및 계산기(Bitcoin Fee Estimator & Calculator): 원하는 시간에 블록체인에 기록하기 위해 트랜잭션에 얼마나 많은 수수료를 포함해야 하는지 추정하는 데 도움이 될 수 있다.
    - ex> [https://mempool.space/](https://mempool.space/)
    
    ![그림 2-3. 블록체인에 포함된 트랜잭션에 대한 수수료 추정](./image/image%203.png)
    
    그림 2-3. 블록체인에 포함된 트랜잭션에 대한 수수료 추정
    
    - 트랜잭션 수수료는 네트워크 용량과 확인 속도에 따라 달라진다. 블록에 기록할 수 있는 트랜잭션의 수에는 제한이 있으므로(현재 데이터 1MB 또는 블록당 약 3500개 트랜잭션) 긴급성을 높이기 위해 더 높은 수수료가 필요할 수 있다.
        - 마이너들이 트랜잭션을 확인하도록 강요하는 경쟁이 일어나고 있다. 수수료가 인상되면 더 빠른 확인이 이루어진다.
        
        ![그림 2-4. 비트코인 트랜잭션 실행에 관련된 일련의 이벤트. 6번 ‘블록체인에서 채굴’은 마이너들이 네트워크에서 컨펌할 새로운 블록을 추가하는 것을 의미한다.](./image/image%204.png)
        
        그림 2-4. 비트코인 트랜잭션 실행에 관련된 일련의 이벤트. 6번 ‘블록체인에서 채굴’은 마이너들이 네트워크에서 컨펌할 새로운 블록을 추가하는 것을 의미한다.
        

### 머클루트

---

- 머클루트: 256비트로 저장된 현재 블록의 모든 트랜잭션 상태를 스냅샷으로 보여줄 때 사용된다.
    - 네트워크의 모든 노드가 정확히 같은 트랜잭션 목록을 갖도록 해야 한다면, 각 트랜잭션을 개별적으로 비교해야 하지만, 머클루트를 사용하면 다른 모든 노드의 머클루트와 비교하기만 하면 되기 때문이다.
    - 머클트리의 구조
        
        ![그림 2-5. 샘플 머클트리의 흐름도](./image/image%205.png)
        
        그림 2-5. 샘플 머클트리의 흐름도
        
        - 현재 블록의 트랜잭션 해시를 잎(leaf)으로 사용한다.
    - 트랜잭션 수가 홀수이면 프로세스를 계속하기 위해 마지막 트랜잭션이 복제된다.
        - 머클루트는 블록 해시를 생성하는 데 도움이 되는 중요한 값이다.

![그림 2-6. 비트코인 블록 #125552의 정보](./image/image%206.png)

그림 2-6. 비트코인 블록 #125552의 정보

![그림 2-7. 머클트리의 흐름도](./image/image%207.png)

그림 2-7. 머클트리의 흐름도

- 블록 #125552의 머클루트: `2b12fcf1b09288fcaff797d71e950e71ae42b91e8bdb2304758dfcffc2b620e3`
    - 첫 번째 트랜잭션의 tx 해시: Ha = `51d37bdd871c9elf4d5541be6736ab625e32028744d7d4609d0c37747b40cd2d`
    - 두 번째 트랜잭션의 tX 해시: Hb = `60c25dda8d41f8d3d7d5c6249e2ealb05a25bf7ae2ad6d904b512b31f997elal`
    - 세 번째 트랜잭션의 tx 해시: Hc = `01f314cdd8566d3e5dbdd97de2d9fbfbfd6873e916a00d48758282cbb81345b9`
    - 네 번째 트랜잭션의 tx 해시: Hd = `b519286al040da6ad83c783eb2872659eaf57blbec088e614776ffe7dc8f6d01`
- 머클루트까지의 해시
    - Ha+b(`H_A`, `H_B` 연결 후, 더블(2번) SHA-256 해시 적용) = `0d0eblb4c4b49fd27dl00e9cce555d4110594661blb8ac0534b8879c84959bd4`
    - Hc+d = `bfae954bdb9653ceba3721e85al22fba33585c5762b5ca5abell7b30c36c995e`
    - Ha+b + Hc+d = Merkle root = `2b12fcflb09288fcaff797d71e950e71ae42b91e8bdb2304758dfcffc2b620e3`

→ 블록체인 노드에서 조작을 신속하게 감지할 수 있다.

- 어떤 변조나 부패가 발생하면, 머클루트 해시는 더 이상 다른 노드와 일치하지 않을 것이다.

### 트랜잭션 서명 및 검증

---

- 트랜잭션 입력에는 보내는 주소의 소유자가 트랜잭션을 승인했다는 증거를 제공하는 서명이 포함된다.
    - 서명: 개인키와 트랜잭션 데이터를 입력으로 하는 암호화 알고리즘인 ECDSA를 사용해 생성되고 암호화된다.
        
        ![그림 2-8. 트랜잭션 서명을 생성하기 위한 암호화 프로세스](./image/image%208.png)
        
        그림 2-8. 트랜잭션 서명을 생성하기 위한 암호화 프로세스
        
- 모든 노드가 트랜잭션을 검증할 때 ECDSA 검증 함수를 사용해 서명의 유효성을 쉽게 검증할 수 있다.
    
    ![그림 2-9. 트랜잭션의 서명 확인](./image/image%209.png)
    
    그림 2-9. 트랜잭션의 서명 확인
    
    - 트랜잭션을 허가하는 디지털 서명이 유효한지 확인하는 데 개인키가 필요하지 않다.
- 모든 노드가 공개 정보를 사용해 트랜잭션을 쉽게 검증할 수 있지만 개인키가 필요하기 때문에 서명 자체를 생성할 수는 없다.

### 코인베이스 트랜잭션

---

- 코인베이스 트랜잭션: 모든 블록에 기록된 첫 번째 트랜잭션, 두 가지 값으로 구성된다.
    1. 블록보상
        - 마이너가 블록을 발견하고 네트워크로부터 받는 보상
        - 새로운 비트코인이 전체 공급에 추가되는 형태로 이뤄진다.
    2. 거래 수수료
        - 현재 블록에 추가되는 각 트랜잭션 수수료의 총합
        - 비트코인 수수료 사이트에서 평균 거래 수수료를 확인할 수 있다.
    - 특징
        - 코인베이스라는 입력이 하나 있는데, 입력이 비어 있다.(새로 생성된 코인)
        - 블록 보상을 지급하는 유일한 방법이다.

![그림 2-10. 코인베이스 트랜잭션 예](./image/image%2010.png)

그림 2-10. 코인베이스 트랜잭션 예

- 이전 트랜잭션이 존재하지 않으므로 트랜잭션 해시 값이 0으로 채워진 32바이트를 갖는다.
- 스크립트 서명은 논스 헤더 오버플로와 같이 마이너가 선택할 수 있는 임의의 데이터를 포함될 수 있다.

### 비트코인 트랜잭션 보안

---

- 비트코인 트랜잭션은 푸시 거래로, 송금자가 거래를 시작한다. 푸시 트랜잭션 방식은 보안성이 높으며, 송금자가 자신의 계좌 정보를 노출할 필요가 없다.
    - 전통적인 풀 트랜잭션은 수신자가 거래를 시작하는 방식이다. 보안성이 떨어지는 것을 보완하기 위해, 풀 결제 네트워크(VISA)는 과금, 거래에 이의를 제기하고 환불을 요청할 수 있는 기능을 제공한다.
- 개인키는 256비트 숫자로, 가능한 조합이 2^256개에 달한다. 무차별 공격(Brute Force Attack)에 강하다.(개인키 예측은 사실상 불가능)

## 해시

---

- 암호화 해시: 데이터를 고정된 크기의 문자열로 암호화하는 함수
- 블록체인에서의 특성
    - 입력에 관계없이 결과 해시는 항상 고정된 길이. ex> SHA-256 해시의 길이는 256비트
    - 해시는 단방향 암호화. 데이터를 쉽게 암호화할 수 있지만, 원래 입력으로 되돌리기는 어려움
    - 같은 입력에 대해 항상 같은 해시를 생성하는 결정적(deterministic) 성질
    - 충돌에 강하다. 서로 다른 입력이 같은 해시를 가질 확률이 매우 낮음

- SHA-256: 비트코인에서 일반적으로 사용됨
- Keccak-256: 이더리움에서 일반적으로 사용됨

- 사용 사례: 암호의 해시를 DB에 저장하는 웹 사이트
    - ex> 비밀번호 `FNj:;:k#F43rQ\`의 해시 값(SHA-256)을 저장하고, 로그인 시 입력된 비밀번호를 다시 해싱하여 저장된 값과 비교한다.

### 블록 해시

---

- 블록 해시: 블록이 생성되는 순간 전체 블록체인이 어떤 모습이었는지 보여주는 스냅샷
- 네트워크의 모든 노드는 블록 해시를 참조해 다른 모든 노드와 정확히 일치하는지 확인한다.
    - 만약 어떤 노드(서버 #4)가 다른 블록 해시를 가지고 있다면, 해당 노드의 데이터가 잘못되었을 가능성이 높다.
        
        ![그림 2-11. 네트워크 안의 모든 노드는 같은 블록 해시를 갖고 있다.](./image/image%2011.png)
        
        그림 2-11. 네트워크 안의 모든 노드는 같은 블록 해시를 갖고 있다.
        

- 비트코인 블록 해시 생성: `SHA256(SHA256(Block_Header))`
- Block Header (80 bytes)
    
    
    | 항목 | 내용 | 바이트 크기 |
    | --- | --- | --- |
    | 버전(Version) | 블록 버전 번호 | 4 |
    | 이전 블록 해시
    (hashPrevBlock) | 이전 블록 헤더의 256비트 해시 | 32 |
    | 머클루트 해시
    (hashMerkleRoot) | 현재 블록에 포함된 모든 트랜잭션 기반 스냅샷 (256비트 해시) | 32 |
    | 시간(Time) | 1970-01-01T00:00 UTC 이후 블록 타임 스탬프 (초 단위) | 4 |
    | 비트 수(Bits) | 현재 대상의 콤팩트 형식 | 4 |
    | 논스(Nonce) | 32비트 숫자 (시작은 0) | 4 |
    
    ![그림 2-12. 블록 해시는 연속적인 블록을 하나의 큰 체인으로 연결](./image/image%2012.png)
    
    그림 2-12. 블록 해시는 연속적인 블록을 하나의 큰 체인으로 연결
    
    - 머클루트 해시 계산
        1. 트랜잭션 해시 생성
            - 블록에 포함된 모든 트랜잭션을 개별적으로 SHA-256(이중 SHA-256)으로 해싱하여 트랜잭션 해시 값을 생성한다.
            - 예를 들어, 네 개의 트랜잭션이 있을 경우:
                
                ```java
                H_A = SHA256(SHA256(Tx A))
                H_B = SHA256(SHA256(Tx B))
                H_C = SHA256(SHA256(Tx C))
                H_D = SHA256(SHA256(Tx D))
                ```
                
        2. 트랜잭션 해시들을 짝을 지어 해싱
            - 인접한 두 개의 트랜잭션 해시 값을 연결한 후 다시 SHA-256(이중 SHA-256)으로 해싱한다.
                
                ```java
                H_AB = SHA256(SHA256(H_A + H_B))
                H_CD = SHA256(SHA256(H_C + H_D))
                ```
                
            - 만약 트랜잭션 개수가 홀수라면, 마지막 해시 값을 복제하여 짝을 맞춘다.
        3. 반복적으로 해싱을 수행하여 머클루트 도출
            - 위에서 얻은 해시 값들을 다시 짝을 지어 같은 방식으로 해싱하여 최종 하나의 값(머클루트 해시)을 도출한다.
                
                ```java
                Merkle Root = SHA256(SHA256(H_AB + H_CD))
                ```
                
    - 비트코인의 한 블록에는 모든 트랜잭션들이 다 들어있나?
        - 블록 생성 시 포함된 일부 트랜잭션들만 기록된다.
        - 비트코인 블록에 포함되는 트랜잭션 개수
            - 비트코인의 기본 블록 크기 제한은 1MB이다. (세그윗 적용 이후 가변적으로 증가 가능)
            - 일반적으로 한 블록에는 약 3,500~4,000개의 트랜잭션이 포함된다.
            - 각 트랜잭션의 크기에 따라 포함할 수 있는 개수가 달라진다.
        - 블록에 포함되는 트랜잭션 종류
            1. 코인베이스 트랜잭션 (Coinbase Transaction)
                - 블록의 첫 번째 트랜잭션으로, 새로운 비트코인을 생성하고 마이너에게 보상 지급.
                - 입력이 없는 특별한 트랜잭션.
            2. 일반 트랜잭션
                - 네트워크에서 전송된 비트코인 거래.
                - 수수료가 높은 트랜잭션이 우선적으로 블록에 포함됨.
        - 모든 트랜잭션을 검색하려면?
            - 전체 트랜잭션을 확인하려면 블록 익스플로러(Block Explorer) 같은 서비스를 사용해야 한다.
            - 블록 내 트랜잭션을 직접 저장하지 않는 가벼운 노드(라이트 노드)는 머클루트만을 사용해 특정 트랜잭션의 포함 여부를 검증(SPV)한다.

## 커스터디: 개인키는 누가 갖고 있는가

---

- 커스터디: 자산을 보유, 이동, 보호할 수 있는 능력

### 지갑 유형 : 수탁형과 비수탁형

---

- 암호화폐 지갑은 암호키를 저장하고 안전하게 유지하기 위한 인터페이스, 물리적으로 존재하지 않는다.
1. 수탁형(Custodial) 지갑
    - 신뢰할 수 있는 엔티티(ex> 거래소)가 관리하며, 사용자는 웹 인터페이스를 통해 접근
    - 개인키를 사이트가 대신 보관하므로 사용자는 분실 걱정 없음
    - ex> 코인베이스(Coinbase)
    - 단점: 거래소가 파산하거나 해킹될 경우 사용자는 키를 통제할 수 없음
        - 서비스를 신뢰해야 함
2. 비수탁형(Noncustodial) 지갑
    - 사용자가 직접 키 제어, 잃어버리면 자금에 접근 불가
    - ex> 블록체인닷컴(Blockchain.com)
    - 단점: 컴퓨터 보안 경험이 없는 사람에게는 권장되지 않음

### 지갑 유형 변형

---

- 핫 월렛: 인터넷에 연결된 지갑
    - 거래 생성 시 키를 쉽게 사용할 수 있다.(자금 이동이 쉽다)
    - 거래소 지갑, 웹 지갑 등 대부분의 커스터디형(custodial) 지갑이 이에 해당한다.
- 콜드 월렛: 개인키가 오프라인에 저장되는 지갑
    - 종이 조각이나 인터넷과 분리된 물체에 있을 수 있다.
    - 대형 암호화폐 업체들은 보안을 위해 자금 대부분을 콜드 월렛에 보관한다.
    - 콜드 월렛(하드웨어 지갑)에서 출금하는 과정
        1. 평소에는 인터넷과 분리된 상태(오프라인)로 보관
            - 개인키는 레저(Ledger) 같은 하드웨어 지갑 내부에 암호화된 상태로 저장됨
            - 온라인에 연결되지 않으므로 해킹 위험이 낮음
        2. 출금하려면 레저를 컴퓨터 또는 모바일에 연결
            - USB, 블루투스 등을 통해 레저(Ledger) 기기를 컴퓨터 또는 스마트폰에 연결
            - 레저 라이브(Ledger Live) 같은 소프트웨어를 실행하여 거래를 준비
        3. 트랜잭션 생성 후, 하드웨어 지갑에서 서명(Sign)
            - 레저는 사용자의 개인키를 내부에서 사용하여 서명을 생성
            - 이 과정에서 개인키가 외부로 노출되지 않음
            - 서명된 트랜잭션이 네트워크로 전송되어 블록체인에 기록됨
        4. 출금 완료
            - 서명된 트랜잭션이 네트워크에서 검증되면 출금 완료
        
        → 콜드 월렛이 인터넷과 연결되지 않는다 == 개인키가 오프라인이라는 의미
        
        - 출금 자체가 불가능하다는 뜻이 아님. 출금할 때는 하드웨어 지갑을 연결해야 하며, 내부에서 서명이 이루어지는 방식으로 보안성을 유지한다.

- 하드웨어 지갑: 사용자에게 자금을 콜드 월렛으로 보관할 수 있게 해준다.(콜드 월렛의 한 종류)
    - 인터넷과 지속적으로 연결되지 않는 비수탁형 지갑. 거래 승인 시에만 연결한다.
    - 암호화된 키의 안전한 저장을 보장한다.
    - ex> 레저(Ledger), 킵키(KeepKey)
    - ✅ 다중자산 지원, 대량의 암호화폐를 저장하기 위한 좋은 콜드 스토리지 방법
    - ❌ 다른 월렛에 비해 사용하기가 쉽지 않음, 자금은 쉽게 접근할 수 없음
    - 바이비트 3조 털림: 콜드 → 웜 과정에서의 Call Data Injection 공격
        - Call Data Injection?
            - 이더리움 스마트 컨트랙트에서 트랜잭션 데이터(Call Data)를 조작하여 원래 의도한 동작과 다른 결과를 유도하는 공격 기법
            - 특히, MultiSig 지갑과 같은 스마트 컨트랙트 기반 지갑을 대상으로 악용될 가능성이 큼
        - Call Data: 스마트 컨트랙트 호출 시, 실행할 함수와 매개변수를 인코딩하여 전달하는 데이터
            - 특정 함수 실행을 위한 메서드 ID + 파라미터 값들이 포함됨
            - 이더리움 트랜잭션은 다음과 같은 주요 필드를 포함한다.
                1. `nonce` - 트랜잭션 순서를 나타냄
                2. `gasPrice` - 가스 비용
                3. `gasLimit` - 실행에 사용 가능한 가스 제한
                4. `to` - 받는 주소 (일반 계정 or 스마트 컨트랙트)
                5. `value` - 전송할 ETH의 양
                6. `data` - 스마트 컨트랙트 실행을 위한 추가 데이터 (Call Data)
        - 공격 시나리오: MultiSig 지갑을 노린 Call Data Injection
            1. MultiSig 지갑 운영 방식
                - MultiSig 지갑에서는 여러 명의 서명자가 특정 트랜잭션을 승인해야 자금이 이동됨
                - 사용자가 트랜잭션을 만들면, 서명자들이 이를 검토 후 서명을 수행
                - 서명이 모이면, 최종적으로 `executeTransaction()` 함수를 실행하여 트랜잭션이 체결됨
            2. Call Data Injection을 이용한 공격 흐름
                
                1️⃣ 해커가 MultiSig 지갑의 트랜잭션 요청을 감염시키거나, 트랜잭션을 생성하는 프론트엔드를 조작
                
                - 서명자들에게 정상적인 트랜잭션처럼 보이도록 함
                - 예: 트랜잭션 요청을 정상적인 웜 월렛 주소로 표시하지만, 실제 `callData`에는 해커 지갑 주소가 포함됨
                
                2️⃣ 서명자들이 Call Data를 정확히 검증하지 않고 서명
                
                - UI에서는 정상적인 주소가 보이므로, 서명자는 정상적으로 서명했다고 착각
                - 하지만 실제 Call Data에는 해커의 지갑 주소가 포함됨
                
                3️⃣ 서명이 완료된 후, `executeTransaction()` 함수 실행
                
                - MultiSig 지갑이 `callData`를 읽고 실행
                - `callData`가 변조되었기 때문에, 자금이 해커 지갑으로 송금됨
        - Call Data Injection 공격 코드 예시
            - 원래의 MultiSig 트랜잭션
                
                ```solidity
                function executeTransaction(
                    address to,
                    uint256 value,
                    bytes memory data
                ) public onlyOwner {
                    require(isApprovedBySigners(), "Not enough signers!");
                    (bool success, ) = to.call{value: value}(data);
                    require(success, "Transaction failed!");
                }
                ```
                
                - `to`: 받는 사람 주소
                - `value`: 송금할 ETH 양
                - `data`: 스마트 컨트랙트 실행을 위한 Call Data
                    - 정상적인 Call Data
                    
                    ```solidity
                    0xa9059cbb000000000000000000000000123456789abcdef123456789abcdef1234567890
                    ```
                    
                    - 0xa9059cbb → `transfer(address,uint256)` 함수 호출
                    - 123456789abcdef... → 정상적인 웜 월렛 주소
            - 해커가 Call Data를 조작한 경우
                - 변조된 Call Data
                    
                    ```solidity
                    0xa9059cbb000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef
                    ```
                    
                    - 해커의 지갑 주소(deadbeef...)가 삽입됨.
                - 해커가 실행한 트랜잭션
                    
                    ```solidity
                    executeTransaction(
                        legitWallet,  // 정상적인 웜 월렛 주소 (UI에 표시됨)
                        10 ether,
                        0xa9059cbb000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef
                    );
                    ```
                    
                    → UI에서는 `legitWallet`로 보이지만, Call Data가 변조되어 실제 실행은 `deadbeef...`로 송금됨
                    
        - **Call Data Injection 방어 방법**
            
            1️⃣ MultiSig 서명 과정에서 Call Data를 검증하는 추가 절차 도입
            
            - UI에서 보이는 주소가 아닌, 실제 서명할 트랜잭션의 Call Data를 직접 확인해야 함
            
            2️⃣ 하드웨어 월렛을 이용한 검증
            
            - Trezor/Ledger 같은 하드웨어 지갑을 사용하여, Call Data를 하드웨어 지갑에서 직접 확인 후 서명하도록 설정
            
            3️⃣ EIP-712 표준 사용 (Signed Typed Data)
            
            - EIP-712 표준을 사용하면 트랜잭션 데이터를 사람이 읽을 수 있는 형태로 변환하여 서명하도록 설계할 수 있음
            - 예를 들어, 서명 UI에서 다음과 같이 표시 가능:
                
                ```
                보내는 주소: 0x123456...
                받는 주소: 0xabcdef...
                전송 금액: 10 ETH
                ```
                
                - 이 데이터와 실제 Call Data를 대조하여 검증하는 절차를 추가하면 공격을 예방할 수 있음
            
            4️⃣ 서명된 트랜잭션을 별도의 오프라인 환경에서 검토
            
            - 트랜잭션을 서명하기 전에 오프라인에서 Call Data를 별도로 검토하는 절차 도입
- 페이퍼 월렛 (Paper Wallet): 개인키를 인쇄해 오프라인에서 안전하게 보관하는 비수탁형 지갑
    - ex> Walletgenerator.net, MyEtherWallet
    - ✅ 키가 오프라인이라 온라인 탈취 위험 최소화
    - ❌ 키를 제대로 저장하지 않으면 물리적 손상이 발생할 수 있음
- 웹 월렛 (Web Wallet): 브라우저 기반으로 운영되는 지갑
    - ex> 코인베이스(수탁형), 블록체인닷컴(비수탁형)
    - ✅ 접근성이 좋고, 구매/판매 가능
    - ❌ 키를 직접 제어하지 못하고, 서비스를 신뢰해야 함
- 데스크톱 월렛 (Desktop Wallet): 윈도우, 맥, 리눅스에서 실행되는 소프트웨어
    - ex> Electrum(비트코인), MetaMask(이더리움)
    - ✅ 사용자가 키를 제어, 오프라인에서도 사용 가능
    - ❌ 보안은 사용자가 유지해야 함
- 모바일 월렛 (Mobile Wallet)
    - ex> Mycelium(비트코인), Edge(다중 자산 지원)
    - ✅ 어디서든 트랜잭션을 보낼 수 있음
    - ❌ 보안이 취약하며, 대량의 자산을 보관하기에는 부적절

## 보안 기본사항

---

- 개인키를 비공개로 유지하는 것이 중요하다.

- 인증 발급 과정
    - 신원 검증: 암호화폐를 요구하는 의심스러운 요청이 있을 경우, 상대방의 신원을 확인해야 한다.
    - 2단계 인증(2FA): OTP(구글)나 하드웨어 기기 인증(YubiKey)을 사용하여 보안을 강화할 수 있다.

- 공격 유형
    - 휴대폰 포팅: 공격 대상 전화번호의 메시지를 가로채는 공격. SMS 대신 안전한 인증 방법(ex> 구글 보이스)을 사용해야 한다.
    - 피싱: 개인정보를 공개하도록 권장하는 링크가 포함된 메시지를 보낸다. 검증되지 않은 메시지에는 응답하지 않아야 한다.

### 복구 시드

---

- 복구 시드: 비수탁형 지갑에 저장된 개인키를 검색하는 데 사용할 수 있는 일련의 단어
    - 종이에 시드를 적고 코딩을 하는 방식으로 필체가 희미해지지 않도록 해야 한다.
    - 금속 시드 저장 장치도 좋다. 다만, 부식이나 습도와 같은 요소를 고려해야 한다.

## 채굴

---

- 비트코인의 채굴은 초기에는 취미로 가능했으나, 시간이 지나며 전문화되었다.
    - 2010년에는 1BTC가 0.3달러, 당시 블록 보상은 50 BTC 였다. 마이너들은 큰 수익을 얻지 못했다.

### 채굴은 인센티브에 관한 것

---

- 초기에는 CPU로도 채굴이 가능했지만, 이후 GPU를, 효율성을 높이기 위해 집적회로(ASIC)가 등장했다.
    - 현재는 거대한 데이터센터에서 이루어지며, 전력 소비와 냉각 비용이 중요한 요소가 되었다.
    
    ![그림 2-14. 가격만큼 변동성이 큰 비트코인의 채굴 수익](./image/image%2013.png)
    
    그림 2-14. 가격만큼 변동성이 큰 비트코인의 채굴 수익
    

### 블록 제너레이터

---

- 채굴: 블록을 만드는 작업을 증명(Proof of Work, PoW)하는 과정
    - 많은 암호화폐는 작업 증명 합의 알고리즘을 사용
    - 비트코인의 경우 특정 패턴과 일치하는 해시를 찾는 퍼즐을 풀기 위해 계산을 실행함으로써 작업이 증명된다.
- 해시는 완성되면 채굴되는 블록의 주소를 보여준다. 퍼즐이 해결되면 블록이 블록체인에 추가된다
- 비트코인은 채굴 난이도를 조절하여 블록 생성 간격이 평균 10분이 되도록 설계되었다.

## 합의

---

- 합의: 블록체인 네트워크가 성공적으로 동작하는지에 관한 중요한 요소

### 작업 증명

---

- 작업 증명(PoW): 비트코인의 합의 방식, 마이너들이 블록을 생성하기 위해 계산을 수행하는 과정이다.
    - 비트코인은 SHA-256 해시 알고리즘을 사용한다.

- 블록 발견
    - 유효한 비트코인 블록 해시 기준
        1. 유효한 블록 헤더 해시를 생성한다.
        2. 생성된 블록 해시는 네트워크 목표치보다 낮아야 한다.
    - 대상(target): 항상 유효한 블록 해시보다 높게 유지해야 하는 끊임없이 변화하는 숫자
    - 난이도(difficulty): 유효한 블록 해시를 발견하는 데 필요한 평균 시도 수
    - 네트워크 해시 레이트(hash rate): 마이너들이 유효한 블록 해시를 생성하기 위해 초당 시도하는 횟수
    - 비트코인은 2016개 블록(약 14일)마다 난이도를 조정하여 블록 생성 간격을 10분으로 유지한다.

- 마이닝 프로세스
    - 유효 비트코인 블록의 내용
        
        
        | 필드 | 내용 |
        | --- | --- |
        | 버전(Version) | 마이너가 현재 사용하고 있는 비트코인 클라이언트 버전 |
        | 이전 블록 해시(hashPrevBlock) | 마이너가 지금 보고 있는 마지막 블록의 해시 |
        | 머클루트 해시(hashMerkleRoot) | 마이너가 현재 블록에 포함하기로 결정한 모든 트랜잭션의 해시 |
        | 시간(Time) | 1970-01-01T00:00 UTC 이후 몇 초로 계산된 블록 타임스탬프 |
        | 비트 수(Bits) | 현재 비트코인 네트워크 대상 |
        | 논스(Nonce) | 0에서 시작. 결과 해시가 잘못되면 1을 추가하고 새 해시를 시도 |
        
        ![그림 2-18. 작업 증명 프로세스 마이너는 새로운 블록을 발견하려고 시도한다.](./image/image%2014.png)
        
        그림 2-18. 작업 증명 프로세스 마이너는 새로운 블록을 발견하려고 시도한다.
        
    - 해당 블록이 네트워크에 전파되면, 다른 마이너들도 이를 확인하고 블록체인에 추가하는 과정이 진행된다.
        
        ![그림 2-19. 두 명의 마이너가 동시에 새로운 블록을 발견하는 이벤트](./image/image%2015.png)
        
        그림 2-19. 두 명의 마이너가 동시에 새로운 블록을 발견하는 이벤트
        
        - 가장 긴 체인 규칙: 만약 동일한 높이에서 두 개 이상의 블록이 발견되면, 가장 긴 체인이 선택되는 작업 증명의 규칙에 따라 블록이 확정된다.

- 트랜잭션 라이프 사이클(비트코인)
    1. 브로드캐스트
        - 유효한 비트코인 트랜잭션을 생성한 후, 이를 네트워크에 전파한다.
        - 코인베이스 같은 온라인 지갑을 사용하거나, 클라이언트 소프트웨어를 통해 확인할 수 있다.
    2. 언컨펌드/멤풀
        - 네트워크의 모든 마이너가 수신한 트랜잭션을 메모리 풀(mempool)에 배치한다.
        - 멤풀은 아직 컨펌되지 않은 활성 상태의 트랜잭션 모음
        - 기본적으로 2주 이상 멤풀에 있는 트랜잭션은 비활성 상태로 간주돼 멤풀에서 삭제된다.
    3. 마이너에 의해 컴펌됨
        - 새로운 블록이 발견될 때, 마이너가 멤풀에서 거래 수수료가 높은 트랜잭션을 우선적으로 포함해 블록을 생성한다.
        - 마이너가 포함한 트랜잭션은 마이너에 의해 컨펌된 것으로 간주된다.
    4. 네트워크에서 컨펌됨
        - 새 블록이 네트워크 전체에 전파되면서, 다른 블록 아래에 묶일수록 컨펌 횟수가 증가한다.

- 컨펌
    - 비트코인 사용자들은 네트워크의 컨펌 횟수를 기준으로 트랜잭션을 신뢰한다.
    - 적어도 6번의 컨펌일 때 네트워크에 의해 안전하게 컨펌되는 트랜잭션으로 간주한다.
    - 트랜잭션이 컨펌된 횟수가 많을수록 비트코인 네트워크의 블록체인에 포함될 가능성이 높아진다.
    
    ![그림 2-20. 블록체인에 포함할 블록을 결정하는 작업 증명 마이너의 예](./image/image%2016.png)
    
    그림 2-20. 블록체인에 포함할 블록을 결정하는 작업 증명 마이너의 예
    

### 지분 증명

---

- 지분 증명(PoS): 채굴을 필요로 하지 않고, 블록을 생성하는 방식
    - 네트워크 참여자는 자신의 암호화폐 보유량(지분, stake), 보유 기간 등에 따라 블록 생성 기회를 얻는다.
- PoW처럼 계산 자원이 필요하지 않으며, 노드는 트랜잭션 검증 역할만 수행.
- PoS 네트워크에서 블록을 생성하는 노드를 밸리데이터(Validator) 라고 한다.

- 장점
    - 에너지 소모가 적음
    - 네트워크에 더 많은 투자를 하는 사람들에게 더 많은 통제권을 준다.
- 단점
    - 지분이 많은 사용자가 네트워크 통제권을 갖게 될 위험 존재 (중앙 집중화)
    - 'Nothing at Stake' 문제: 밸리데이터가 여러 포크(체인 분기)에 투표하는 문제가 발생할 가능성이 있음
        - 이를 방지하기 위해 슬래싱(Slashing) 알고리즘 적용
            - 네트워크의 합의 규칙을 위반한 벨리데이터에게 지분(Staking한 코인)을 삭감하는 방식

### 합의를 위한 다른 개념

---

- 스토리지 증명 (Proof of Storage, PoSt): 블록 검증을 위해 저장 공간을 활용하는 방식
    - ASIC 기반 채굴이 필요하지 않아 저비용으로 운영 가능
    - ex> 퍼마코인(Permacoin), 토르코인(Torcoin), 치아(Chia) 등
- 기록 증명 (Proof of History, PoH): 네트워크가 독립적으로 타임스탬프를 생성하여 합의 과정 속도를 높이는 방식
    - ex> 높은 처리 속도의 Solana
- 위임 지분 증명 (DPoS, Delegated Proof of Stake): 사용자가 토큰을 특정 대표자에게 위임하여 네트워크를 관리하는 에너지 효율적인 방식
    - 퍼블릭 블록체인보다는 프라이빗 블록체인에서 주로 사용됨

## 이해관계자

---

- 암호화폐에서 상호 작용할 수 있는 이해관계자: 브로커, 거래소, 보관 서비스, 분석 서비스, 정보 제공자

### 브로커리지

---

- 암호화폐 거래의 원활한 진행을 돕는 중개 서비스로서 암호화폐를 사고 팔고 보유하는 중개자 역할을 한다.
    - 브로커리지 거래: 사용자를 대신해 암호화폐를 구매하고 보유하는 역할을 함
    - 가맹점 거래: 비트코인이나 암호화폐 결제 처리를 담당
        - 가맹점은 암호화폐를 직접 보유하지 않고, 브로커리지 서비스를 통해 법정화폐로 변환하여 지급받을 수도 있음
- ex> 로빈후드(Robinhood), 스퀘어(Square)의 캐시 앱(Cash App), 비트페이(BitPay)

### 거래소

---

- 법정화폐(Fiat)와 암호화폐를 교환하는 중심 플랫폼
    - 거래소를 통해 사용자들이 직접 암호화폐를 거래할 수 있음

### 커스터디(보관 서비스)

---

- 암호화폐를 보관한다.
    - 핫, 웜, 콜드 스토리지 서비스를 제공한다.
    - 콜드 스토리지는 인출하는 데 시간이 걸릴 수 있다.
- ex> 비트고(BitGo), 코인베이스

### 분석(분석 서비스)

---

- 암호화폐 블록체인에서 생성된 데이터를 분석해 사용자들이 쉽게 접근할 수 있도록 제공한다.

- 트랜잭션 조회
    - ex> 블록체인 익스플로러(Blockchain Explorer)
        
        ![그림 2-21. 블록체인 익스플로러의 비트코인 트랜잭션의 모습](./image/image%2017.png)
        
        그림 2-21. 블록체인 익스플로러의 비트코인 트랜잭션의 모습
        
- 블록 데이터 조회
    - ex> 비트코인닷컴, 이더스캔(Etherscan)
- 트랜잭션 추적
    - 거래소나 기타 이해관계자들이 거래를 식별하는 데 도움을 준다.
    - ex> 체이널리시스(Chainalysis)

### 정보

---

- 블록체인 산업은 빠르게 변화하며, 관련 정보를 제공하는 기업으로 코인데스크(CoinDesk)가 대표적이다.
- 주요 언론사인 뉴욕타임스, 월스트리트 저널, 블룸버그 등도 블록체인 전문 저널리스트와 함께 암호화폐 산업을 분석한다.
- 암호화폐 컨퍼런스는 교육 자원이지만 비용이 많이 들며, 지역별 미팅을 통해 무료로 정보를 얻을 수도 있다.

## 요약

---

- 암호화폐의 기본 개념은 처음에는 어렵지만, 블록체인의 기초를 이해하면 점점 쉽게 접근할 수 있다.
