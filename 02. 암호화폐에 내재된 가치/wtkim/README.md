# 2장 암호화폐에 내재된 가치

### 암호화폐 시스템의 개인키 / 공개키

<p align="center">
    <img width="600" alt="Image" src="https://github.com/user-attachments/assets/d15b0c81-7c3e-4117-9394-fcd9a5208788" />
</p>

- **개인키**
    - 무작위 생성기에 의해 생성된 256 비트(16진수 형식) 숫자
    - 사용자는 개인키를 사용해 공개키와 비트코인 주소를 생성할 수 있다.
- **공개키**
    - **비트코인을 ‘수신’** 하는데 사용되는 키로써, 비트코인 출력을 공개키에 잠글 수 있어 개인 키 소유자만 잠금을 해제하여 다음 거래에 사용할 수 있다.
    - **타원 곡선 디지털 서명 알고리즘(Elliptic Curve Digital Signature Algorithm, ECDSA)** 을 실행하기 위해 [**secp256k1 curve**](https://en.bitcoin.it/wiki/Secp256k1) 매개변수를 사용한다.
        - secp256k1 curve 의 생성자 포인트 G 에 개인키를 곱하여 (multiply() 연산) 공개키가 만들어진다.
        - Satoshi 는 왜 secp256k1 를 사용했는가? (개발 당시 많은 이슈에 할애할 수 있는 시간이 적어 그냥 하나를 골랐다고 함)
    - **비트코인 주소 생성을 위해** 공개키는 해시 함수를 사용해 해시 되는데, 이때 **SHA-256 & RIPEMD-160 (HASH160)** 알고리즘을 한번씩 거쳐  만들어진다.

### UTXO 모델

비트코인은 UTXO(사용되지 않은 트랜잭션 출력) 모델을 사용한다. 비트코인 거래 수수료는 블록을 발견한 채굴자에게 인센티브로 지급된다.

### 트랜잭션

<p align="center">
    <img width="600" alt="Image" src="https://github.com/user-attachments/assets/498f5240-db2f-47d4-8fc9-d85259430f03" />
</p>

자금의 통제권을 양도하기 위해서는 개인키로 트랜잭션에 서명해야 한다. 해당 공개키는 수신자가 서명을 확인하고 트랜잭션을 검증하는데 사용한다. 이 거래가 성사되기 위해, 네트워크에 소정의 수수료를 지불해야 한다.

트랜잭션이 빨리 성사되길 원한다면, 비트코인 네트워크 에서는 수수료를 인상하여 기존 트랜잭션을 덮어 씌우면 더 빨리 **컨펌(Confirm)*** 이 일어난다.

- **컨펌(Confirm)**
    - 트랜잭션 검증 과정이 모두 완료되어 네트워크에 게재되면, Confirm 되었다고 표현한다.

**머클루트**

<p align="center">
    <img width="600" alt="Image" src="https://github.com/user-attachments/assets/11f41c3e-11fe-418e-8dfa-fd4a80eaae4a" />
</p>

현재 블록의 모든 트랜잭션 상태를 스냅샷으로 보여주기 위해 사용되는 알고리즘

머클트리 구조를 사용하면, 머클루트를 통해 블록체인 노드에서의 조작을 신속하게 감지할 수 있다.

**트랜잭션 서명 및 검증**

ECDSA 검증은 서명, 공개키, 트랜잭션 데이터를 통해 유효성을 검증할 수 있다. 이때 개인키는 필요하지 않다. 공개 정보만으로 검증할 수 있다는 점이 중요하다.

**코인베이스 트랜잭션**

**모든 블록에 기록된 첫 트랜잭션을 의미한다.** 여기에는 **블록보상** (채굴자가 네트워크로 부터 받는 보상) 과 **거래 수수료** (현재 블록에 추가되는 각 트랜잭션 수수료의 총합) 값으로 구성된다.

**보안**

비트코인 거래는 **Push** 거래이기 때문에, 자신의 계좌정보를 노출하지 않고 거래할 수 있어 안정성이 높다.

**해시**

암호화 해시는 다음과 같은 특징들이 있다.

- 결정적(Deterministic) - 입력 값이 같으면 결과 해시는 항상 같다. 이는 입력 값의 변조로 인한 해시의 손상을 확인하기 쉽다는 의미이다.
- 같은 해시를 만드는 서로 다른 입력을 값을 찾을 가능성은 매우 낮기 때문에, 해시 충돌에 강하다.

블록 해시를 산출하기 위해 [**이중 SHA-256(HASH256)**](https://learnmeabitcoin.com/technical/cryptography/hash-function/) 방법이 일반적으로 사용된다. 블록 해시 산출뿐 아니라, **TXID 생성, 머클루트, 체크섬 산출 등에도 이 알고리즘이 사용된다.**

암호화 해시 알고리즘은 코인마다 조금씩 다르다. (이중 SHA-256 (비트코인), Keccak-256 (이더리움) 등)

**블록(Blocks)**

블록 해시는 블록 생성 시, 전체 블록체인이 어떤 모습이었는지 보여주는 스냅샷이다. 이를 통해 블록체인의 변조나 손상을 확인할 수 있다.

블록체인에 추가할 후보 블록에는 **블록 헤더** 가 있고, 여기에서 몇가지 정보가 있지만 중요한 것은 **머클루트 해시, 논스** 이다.

채굴자가 블록을 체인에 등록할 때 만들 블록 해시 값은 **타겟** * 보다 낮아야 한다. 이 타겟은 **난이도** * 라는 값으로 부터 계산되며, 블록 해시는 **논스** * 를 사용하여 해시된다.

### 커스터디

지갑은 개인키가 어떻게 관리되느냐에 따라 수탁형, 비수탁형으로 구분된다.

- 수탁형
    - 신뢰할 수 있는 엔티티에 의해 발급된 계정(Account) 에 암호화폐를 가지고 있고 서비스 인터페이스를 통해 키를 제어하는 형태
    - 직접 키를 제어할 수 없기 때문에 신뢰할 수 있는 서비스를 선택해야 한다.
- 비수탁형
    - 사용자에게 개인키를 완전히 제어할 수 있게 하는 형태
    - 개인키의 보안에 대해 개인에게 책임을 전적으로 부여한다.
    - 지갑 발급 시, **복구 시드** 를 발급하여 보관하게 한다. 이것을 잃어버리면 개인키 검색 수단을 완전히 잃어버리게 된다.

**지갑 유형**

- 핫 월렛(Hot-wallet) - 오픈된 인터넷 연결을 통해 쉽게 키를 사용할 수 있다.
- 콜드 월렛(Cold-wallet) - 개인키를 완전한 오프라인에서 저장한다.
- 하드웨어 월렛(Hardware wallet) - 콜드 스토리지의 일종으로, 실물 디바이스를 사용해 거래가 필요할 때만 웹에 접근하고 비수탁형이다.

### 채굴

<p align="center">
    <img width="600" alt="Image" src="https://github.com/user-attachments/assets/3ddd7b41-a0da-4c96-994a-1904cbb28788" />
</p>

대부분의 암호화폐는 블록을 발견하기 위해 작업 증명이라는 합의 알고리즘을 사용하기 때문에 채굴이 필요하다.

- **작업 증명** *
    - 작업 증명 채굴은 메모리 풀에서 거래를 후보 블록에 채우는 것으로 시작한다. 타겟보다 낮은 블록 해시를 만들기 위해 논스를 올리고, 해시하는 과정을 반복한다. 그렇게 낮은 해시를 얻게 되면 해당 블록을 네트워크의 나머지에 브로드캐스트 한다. 각 노드는 블록 헤더가 타겟보다 낮게 해시되었는지 확인한 후, 자신들의 네트워크에 블록을 추가 **(Confirmed)** 하면서 동기화 작업이 완료된다.
    - **작업 증명은 블록 해시를 타겟보다 낮은 값으로 내리기 위해 필요한 만큼의 작업을 수행했다는 사실을 가리킨다.**
- **지분 증명(Staking)** *
    - 채굴을 사용하지 않고 작업 증명을 개선하기 위한 합의 알고리즘이다.
    - 암호화폐 보유자는 의결권(지분)을 얻기 위해 자신들의 자금을 스테이킹한다. 지분 크기, 기간 등에 따라 노드를 선택하고, 검증자(Validator)로써 활동하게 되며 스테이킹에 대한 보상을 받는다.
    - On-chain 에서는 최소 스테이킹 금액으로 많은 자금이 필요하며, 서비스형 스테이킹은 필요 자산을 분산 모집하여 얼마를 보유하든 스테이킹 할 수도 있다.
- **타겟(Target)**
    - 유효한 블록 해시보다 높게 유지되어야 하는 숫자.
- **난이도(difficulty)**
    - 네트워크에 많은 채굴자가 참여해도 거래 블록이 정기적으로 블록체인에 등록되는 것을 보장하기 위한 조정 값이다. 평균적으로 이 값만큼 작업 증명을 시도한다. **타겟(Target)** 의 높이를 조절하는데 사용된다.
    - 난이도가 높아도, 직접적으로 GPU 처리 성능을 높이면 해시레이트(채굴 속도)를 높일 수 있다.
    - 비트코인의 난이도는 2,016 블록 채굴 (대략 1주일) 마다 업데이트 된다.
- **논스(Nonce)**
    - 블록 해시 값을 타겟 보다 낮추기 위한 더미 필드이다. 따라서 블록 헤더는 타겟보다 낮은 값을 찾기 위해 그 자체로 해시되지 않고, 이 논스를 사용해 해시된다. 논스는 해시가 유효하지 않으면 해시가 적정한 높이를 찾을 때까지 계속 증가한다.

### 비트코인 트랜잭션 분석

- 비트코인 거래의 수수료
    - UTXO 입력 값의 총 합계 - 출력 값의 총 합계
    - vByte * 지불할 sat
- [**세그윗(Segwit, Segregated Witness Upgrade)**](https://learnmeabitcoin.com/beginners/guide/segwit/) *
    - **트랜잭션의 가변성**을 해결하기 위해 나온 개념
    - **레거시 트랜잭션 데이터는** 각 Input 데이터 옆에 Signature 데이터가 있어 거래 데이터 전체에 분산되고, 그 다음 전체 거래 데이터 에서 TXID 가 생성된다.
    - **세그윗 업그레이드 이후** 트랜잭션 데이터는 모든 Signature 데이터가 트랜잭션 데이터의 끝으로 이동한다. 그 다음 **Signature 데이터를 제외한** 거래 데이터에서 TXID 가 생성된다.
    - **세그윗 업그레이드의 장점**
        - 레거시 네트워크에 트랜잭션을 보내기 전, 기존 TXID 에서 Input 의 서명을 변경하는 해킹을 통해 새로운 TXID2 를 만들어 낼 수 있다. **세그윗 거래는 이 가변성을 제거하여 TXID 를 안정적으로 만든다.**
        - 블록 데이터 크기의 가중치 단위가 4배 늘어났다. 업그레이드 이후, 블록 전체에서 거래 데이터를 위한 공간이 넓어졌다는 것을 의미한다.
- [**비트코인 Row transaction**](https://learnmeabitcoin.com/technical/transaction/#structure)
    - **주요 구성요소**
        - **프로토콜 버전 정보** (4 byte)
        - **플래그(Flag)** - **0001** 값을 포함하면, **세그윗(Segwit)** *을 사용한다는 표시이다.
        - **증인(Witness)** - 세그윗을 사용하면 증인 목록을 볼 수 있다. 트랜잭션 데이터에서 witness bytes 파트로 구분된다.
        - **ScriptPubKey** - 출력에 대한 **`잠금 코드`** 이다. 흔한 경우 공개 키에 출력을 잠글때 사용하며, 출력에 다양한 잠금을 설정할 수 있는 Script 라는 미니 프로그래밍 언어로 구성되어 있다. 레거시 잠금 스크립트는 [P2PK](https://learnmeabitcoin.com/technical/script/p2pk/) , [P2PKH](https://learnmeabitcoin.com/technical/script/p2pkh/) , [P2MS](https://learnmeabitcoin.com/technical/script/p2ms/) , [P2SH](https://learnmeabitcoin.com/technical/script/p2sh/) 스크립트로, 최신 잠금 스크립트는 [P2WPKH](https://learnmeabitcoin.com/technical/script/p2wpkh/) , [P2WSH](https://learnmeabitcoin.com/technical/script/p2wsh/) , [P2TR](https://learnmeabitcoin.com/technical/script/p2tr/) 로 구성되어 있으며 **Witness** 섹션에서 잠금 해제된다.
- **비트코인 Row transaction 예제 (Segwit)**
```
020000000001013ce63f3c9d1375b3d7fc59516dbe57120fe3c912a31ebc29241897b16215cc390000000000fdffffff020f900100000000001976a914998db5e1126bc3a5e04109fbf253a7900462410e88acd9bd150000000000160014579bf4f06510c8683f2451262b6685b00012e46f024730440220537f470c1a18dc1a9d233c0b6af1d2ce18a07f3b244e4d9d54e0e60c34c55e67022058169cd11ac42374cda217d6e28143abd0e79549f7b84acc6542817466dc9b3001210301c1768b48843933bd7f0e8782716e8439fc44723d3745feefde2d57b761f5033f600a00

* 순차적으로 해부하기 *

02000000 - version no.

0001 - marker(00), flag(01)

3ce63f3c9d1375b3d7fc59516dbe57120fe3c912a31ebc29241897b16215cc39
- Input 0

00000000 - vOut

00 - ScriptSig Size

fdffffff - Sequence

02 - Output Count

0f90010000000000 - Amount

1976a914998db5e1126bc3a5e04109fbf253a7900462410e88acd9bd150000000000160014579bf4f06510c8683f2451262b6685b00012e46f
- ScriptPubKey 관련 데이터들

024730440220537f470c1a18dc1a9d233c0b6af1d2ce18a07f3b244e4d9d54e0e60c34c55e67022058169cd11ac42374cda217d6e28143abd0e79549f7b84acc6542817466dc9b3001210301c1768b48843933bd7f0e8782716e8439fc44723d3745feefde2d57b761f503
- Witness bytes (Sigwit 트랜잭션이 아니면 해부 불가)

vByte 계산 = 116 x 1 + 109 x 0.25 = 143.25

수수료를 3 sat 으로 전달할 경우 최종 수수료 = 143.25 * 3 = 429.75 sat
```