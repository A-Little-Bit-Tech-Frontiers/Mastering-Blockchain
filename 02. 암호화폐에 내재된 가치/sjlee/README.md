## 2.1 암호화폐 시스템의 공개키와 개인키

공개키 암호화 기법은 비트코인과 같은 암호화폐의 필수 요소다. 예를 들어, 지갑을 생성하면 **공개키와 개인키, 비트코인 주소가 생성**된다. **비트코인 주소는 공개키를 변환한 것**으로, 자금을 받을 수 있고 다른 주소로 보낼 수 있는 지갑의 ID다. 

비트코인 주소는 수신 및 전송을 위해 사용자 이름 또는 이메일 주소와 같이 누구와도 공유할 수 있다. 개인키는 비밀로 유지되며 저장된 암호화폐를 잠금 해제하는 데 사용된다.
(지갑 생성 시, 개인키는 정확히 어디에, 어떻게 보관되는지가 궁금함)

<img width="634" alt="image" src="https://github.com/user-attachments/assets/3314c6b7-43fa-4664-9661-656c7e3005e7" />


**비트코인 개인키**는 디지털로 거래에 서명하는 데 사용된다. 비트코인 주소의 소유자는 **비트코인 네트워크에 주소의 정당한 소유자임을 증명**하고, **거래가 어떻게 승인되는지 증명**한다. 현실에서 ATM에서 카드를 삽입하고 개인 식별번호를 입력한다. 개인 식별번호는 비공개이므로 사용자만 알 수 있다. ATM 네트워크의 경우 유효한 식별번호는 ATM 사용자가 트랜잭션에 서명했음을 나타낸다.

**비트코인 공개키**는 비트코인 **주소를 생성하는 데만 사용**된다. 비트코인 주소는 **본질적으로 공개키의 압축 버전**이므로 훨씬 읽기 쉽다.  비트코인 주소는 누군가가 비트코인을 주소로 보내달라고 요청할 때, 종종 누구와도 공개적으로 공유할 수 있다

비트코인 개인키는 무작위 생성기에 의해 생성된 무작위 256비트 숫자다. 개인키는 16진수 형식으로 표시돼 있다.  사용자가 개인키를 갖고 있다면, 공개키와 페어링해 비트코인 주소를 잠금 해제할 수 있다. 모든 것이 개인키에서 시작된다. 개인키로 사용자는 공개키와 비트코인 주소를 생성할 수 있다.

아래 그림이 비트코인 주소를 생성하는 프로세스다.

<img width="642" alt="image" src="https://github.com/user-attachments/assets/f315e905-4a2b-40aa-93df-68cca65e7799" />


## 2.2 UTXO 모델

비트코인 거래는 미지출 트랜잭션 출력(Unspent Transaction Outputs, UTXO)이라는 방식을 따른다. **비트코인 거래는 입력 목록과 출력 목록으로 구분**된다.

각 **입력**은 과거에 받은 주소와 함께 (자금 제공)비트코인 주소가 있는 **미지출 트랜잭션을 식별**한다. 각 **출력**은 **수신 비트코인 주소**와 **받는 수량**을 보여준다. **입력값과 출력값의 차이**는 비트코인 **마이너가 받게 되는 거래 수수료를 의미**한다. **각 입력에는 비트코인 주소의 소유자가 그 거래를 승인한다는 것을 증명하는 디지털 서명이 포함**돼있다.

아래 이미지가 비트코인 거래 예시다.

<img width="720" alt="image" src="https://github.com/user-attachments/assets/502141d1-71bf-4c66-ab98-21666191d65f" />


**4개의 입력**

- 이전 거래에서 생성된, 사용되지 않은 UTXO에서 가져온 것이다.
- 근데, 가만 보면 4개의 입력 중 2개는 주소가 같고 다른 두 개는 다르다.
    - `1HXpg8D9AMGFVZ9FEU2tkZYvAZ8xBhVudo` 주소는 **과거에 두 개의 서로 다른 UTXO(= 다른 트랜잭션의 출력)를 받았다는 것**을 의미한다.
    - 반면, `14yPyVmGhNCSM9JgaabRZ8C3cT2RWEGd71` & `1MXDLBc2ftQ2hnQ2x5qXTEPuen5xq9hDA39`는 각각 **한 개의 UTXO만 보유**했던 상태였고, 이번 트랜잭션에서 사용된 것이다.
    - 

**2개의 출력**

- 새로운 두 개의 UTXO가 생성되었으며, 이들은 아직 사용되지 않는(Unspent) 상태이다.

**위 거래를 통해 일어나는 일**

- 과거에 받은 UTXO를 사용해서 새로운 거래를 만들었다.
    - `1HXpg8D9AMGFVZ9FEU2tkZYvAZ8xBhVudo` 주소는 두 개의 UTXO를 보유하고 있었고, 이번 거래에서 두 개의 서로 다른 입력으로 사용됨
    - 나머지 두 개의 UTXO는 각각 다른 주소에서 받아 사용됨
- 새로운 UTXO가 생성됨
    - 두 개의 새로운 UTXO가 생성되었고, 이들은 새로운 거래에 입력으로 사용될 것이다.

**그러면,, 결국에 입금되면 새로운 출력(UTXO)가 생성되는거고, 이 출력이 나중에 출금할 때 새로운 입력으로 사용된다?**

비트코인은 **UTXO 모델을 사용하기 때문에**, **입금(거래 출력)이 발생하면 새로운 UTXO가 생성되고, 출금(거래 입력) 시 기존 UTXO가 소멸된다**는 개념이다.

- **입금 시 → 새로운 UTXO 생성**
- **출금 시 → 기존 UTXO를 입력으로 사용 & 새로운 UTXO 생성**
- **한 번 사용된 UTXO는 다시 사용할 수 없음 (소멸됨)**

즉, 이번 거래에서 입력으로 사용된 UTXO는 더 이상 존재하지 않음. 대신, 새로운 주소에서 새로운 UTXO가 생성된 것.

**그럼 위 거래에서 실제 수신주소는 어떤것일까?**

이미지를 다시 보면 **Outputs (출력)** 부분에 두 개의 새로운 UTXO가 생성되었어:

| 수신 주소 | 새로운 UTXO (BTC) | 상태 |
| --- | --- | --- |
| `1K3kGw66JbR8DhHNKgkXd3a17aJaoVyKKN` | `0.00865732 BTC` | Unspent (새 UTXO 생성) |
| `32UfiLzcvfg25JccmNW4oBsr3CdQSFJ2so` | `0.0028 BTC` | Unspent (새 UTXO 생성) |

**즉, 이번 거래에서 수신 주소는 다음 두 개**

1. **`1K3kGw66JbR8DhHNKgkXd3a17aJaoVyKKN`** → **0.00865732 BTC를 받은 주소**
2. **`32UfiLzcvfg25JccmNW4oBsr3CdQSFJ2so`** → **0.0028 BTC를 받은 주소**

비트코인 거래에서는 일반적으로 잔돈 주소는 송신자의 소유 주소(자신의 지갑 주소)일 가능성이 높으므로, 큰 금액이 실제 수신자가 아닐까라는 추측 (이거 맞나?)

입력은 총 0.0128 BTC이고 총 출력은 0.01145732 BTC다. 입력 값에서 출력 값을 뺀 차액은 `0.00134268 BTC`로 블록체인에 블록을 발견한 **마이너에게 수수료로 지급**된다.

트랜잭션을 만들어 낸 사람은 수수료를 가장 빠르게 발견한 마이너에게 인센티브로 지급하고, 메모리 풀에 남아있는 다른 트랜잭션보다 먼저 이 트랜잭션을 포함하도록 한다. 

## 2.3 트랜잭션

암호화폐에서 트랜잭션은 한 주소에서 다른 주소로의 값 이동을 나타낸다. 블록체인에 게재된 트랜잭션은 “컨펌됐다”고 표현한다.

**자금의 통제권을 양도**하려면 **개인키로 트랜잭션을 서명**해야 한다. 그 후, **수신자는 공개키를 통해 서명을 확인**하고 트랜잭션을 검증한다. 

사용자들은 대부분의 암호화폐에서 트랜잭션이 성사되기 위해 네트워크에 소정의 수수료를 지불해야 한다. 통상 거래가 포함된 블록을 발견한 마이너에게 돌아가는 수수료는 마이너들이 지속적으로 네트워크를 보호할 수 있도록 장려하기 위한 것이다.

비트코인 수수료 추정기와 같은 온라인 도구는 원하는 시간에 블록체인에 기록하기 위해 트랜잭션에 얼마나 많은 수수료를 지불해야 하는지 추측해준다.

<img width="671" alt="image" src="https://github.com/user-attachments/assets/b82d7fcf-08cc-47d3-96ba-4335b7928fca" />


비트코인 트랜잭션 수수료는 네트워크 용량과 신속한 확인이 얼마나 필요한지 등에 따라 달라질 수 있다. 블록에 기록할 수 있는 트랜잭션의 수에는 제한(블록당 약 3,500개 혹은 데이터 1MB)이 있으므로 긴급성을 높이기 위해 더 높은 수수료가 필요할 수 있다. 

<img width="544" alt="image" src="https://github.com/user-attachments/assets/6e5f0b22-a1db-4d8a-a486-8d032764ae24" />


## 2.4 머클루트

머클루트는 256 비트로 저장된 현재 블록의 모든 트랜잭션 상태를 스냅샷으로 보여줄 때 사용됨

머클루트를 사용하면 다른 모든 노드의 머클루트와 비교하기만 하면 되기 때문에 다른 노드 간 트랜잭션을 각각 비교할 필요가 없다.(스냅샷을 찍어놓기 때문에, 캐싱 효과를 얻는 느낌)    

머클루트를 계산하려면 먼저 머클트리를 작성한다. 여기서 잎(leaf)은 현재 블록의 트랜잭션이다.

<img width="718" alt="image" src="https://github.com/user-attachments/assets/f60f82bf-ee22-47f1-84f9-70b16126bc0a" />


Ha는 첫 번째 트랜잭션 해시를, Hb는 두 번째 트랜잭션 해시를 의미한다. Hab는 Ha+Hb = H a+b = SHA 256을 의미한다.
**머클루트를 위로 옮기고 모든 잎에 해시를 구하면 머클루트에 도달**한다. 트랜잭션 수가 홀수이면 프로세스를 계속하기 위해 마지막 트랜잭션이 복제된다. 머클루트는 블록 해시를 생성하는 데 도움이 되는 중요한 값이다.

<img width="675" alt="image" src="https://github.com/user-attachments/assets/0ec7a7e1-96bd-4185-9320-a1f2fed6e548" />


머클루트를 사용해 블록체인 노드에서 조작을 신속하게 감지할 수 있다는 점이 가장 중요하다. 주어진 노드의 블록체인에 어떤 변조나 부패가 생긴다면, 머클루트 해시는 더 이상 다른 노드와 일치하지 않을 것이다.

## 2.5 트랜잭션 서명 및 검증

각 트랜잭션 입력에는 보내는 주소의 소유자가 트랜잭션을 승인했다는 증거를 제공하는 서명이 포함된다. 서명은 아래와 같이 개인키와 트랜잭션 데이터를 입력으로 하는 암호화 알고리즘인 ECDSA를 사용해 생성되고 암호화된다.

<img width="370" alt="image" src="https://github.com/user-attachments/assets/32283c0c-2f44-4fd0-99ca-d0f3d9321639" />


모든 노드가 트랜잭션을 검증할 때 ECDSA 검증 함수를 사용해 서명의 유효성을 검증한다.

<img width="440" alt="image" src="https://github.com/user-attachments/assets/fd8cdbf9-5b45-46d3-937c-4d65c9a0e799" />


중요한 것은 트랜잭션를 허가하는 **디지털 서명이 유효한지 확인하는 데 개인키는 필요하지 않다는 점**이다. 모든 노드가 공개 정보를 사용해 트랜잭션을 쉽게 검증할 수 있지만 서명 자체를 생성할 수는 없다.(개인키가 필요하기 때문에)

## 2.6 코인베이스 트랜잭션

**모든 블록에 기록된 첫 번째 트랜잭션**을 코인베이스 트랜잭션이라고 한다. 코인베이스 트랜잭션은 두 가지 값으로 구성된다.

- 블록보상
    
    마이너가 비트코인 네트워크 유지를 위해 블록 발견 작업을 수행하고 네트워크로부터 받는 보상이다. 보상은 새로운 비트코인이 전체 공급에 추가되는 형태로 이뤄진다.
    
- 거래 수수료
현재 블록에 추가되는 각 트랜잭션 수수료의 총합을 의미한다. 블록에 들어갈 수 있는 것보다 더 많은 트랜잭션이 처리 대기 중이어서 빠른 처리를 위해 트랜잭션 수수료 시장이 형성되는 경우가 많다. 마이너에게 트랜잭션 처리를 빠르게 원할수록 거래 수수료는 높아진다.

코인베이스 트랜잭션은 입력이 없으며, 블록 보상을 통한 신규 비트코인 발행 방식이다.

<img width="710" alt="image" src="https://github.com/user-attachments/assets/feacfd0c-e613-43c7-b5c7-7cf487905a2d" />


## 2.7 해시

암호화 해시는 어떤 형태의 데이터든 고정된 크기의 문자열로 암호화하는 함수다. 블록체인에서 해시는 다음과 같은 특성을 가진다. 

- 입력에 관계없이 결과 해시는 항상 고정된 길이다. 예를 들어 SHA-256에 의해 생성된 해시의 길이는 항상 256비트다.
- 해시는 단방향 암호화로 데이터를 쉽게 암호화할 수 있다.
- 반대로 해시를 원래 입력 데이터로 복호화하는 것은 매우 어렵다. 개인키 없이 복호화 하는 유일한 방법은 브루트 포스
- 해시는 결정적(deterministic)이다. 같은 입력 데이터에 대해 항상 같은 출력을 뱉는 것을 의미한다.

암호화 해시 알고리즘이 존재한다. 가장 일반적인 두 가지는 다음과 같다.

- SHA-256: 비트코인에서 일반적으로 사용됨
- Keccak-256, 이더리움에서 일반적으로 사용됨

## 2.8 블록 해시

블록 해시는 블록이 생성되는 순간에 전체 블록체인이 어떤 모습이었는지 보여주는 스냅샷이다. 회계 용어로 말하면 전체 네트워크에 대한 대차대조표와 같다. 네트워크의 모든 노드는 블록 해시를 참조해 네트워크를 보는 시각이 다른 모든 노드와 정확히 일치하는지 확인한다. 노드의 원장에 사소한 차이가 있더라도 그 해시는 상당히 다르게 보일 것이다.
블록 해시로 비교해 블록체인이 변조되거나 손상되는 것을 방지한다.

비트코인 블록 해시는 ‘Block Header’에서 SHA-256 해시 함수를 사용해 생성된다. Blcok Header는 아래 항목과 같이 구성된다.

<img width="710" alt="image" src="https://github.com/user-attachments/assets/ad526262-1d8d-4c78-9897-de44fcd912b4" />


가장 중요한 두 필드는 이전 블록에서 비트코인 네트워크가 어떻게 생겼는지 스냅샷을 제공하는 `hashPrevBlock` 과 현재 블록에 포함된 모든 트랜잭션의 스냅샷인 `hashMerkleRoot`이다.

새로운 블록 해시를 생성할 때, 이전 블록 해시를 포함해 모든 블록이 이전 블록에 연결되거나 체인화가 되도록 한다.

<img width="636" alt="image" src="https://github.com/user-attachments/assets/aeb1d825-e7ca-4fee-a6ab-661bdb7d5422" />


## 2.9 커스터디: 개인키는 누가 갖고 있는가

### 지갑 유형: 수탁형과 비수탁형

암호화폐 **지갑은 암호키를 저장하고 안전하게 유지하기 위한 인터페이스**이다. 암호화폐 자체는 어떤 장치에도 물리적으로 존재하지 않으며, **지갑은 암호키와 연관된 키를 저장하기 위해만 사용된다.** 

일반적으로 암호화된 지갑은 두 가지 유형이 존재함

**수탁형 지갑**은 신뢰할 수 있는 엔티티에 의해 제어되며 사용자는 일반적으로 웹 인터페이스를 통해 내용에 접근해야 한다. 사이트는 사용자를 위한 개인키를 저장한다. 이때 사용자는 개인키 분실을 걱정하지 않아도 된다.  거래소는 수탁형 지갑의 일반적인 예다. 계정에 암호화폐를 갖고 있으며 키를 소유하고 제어한다. 

**비수탁형 지갑**은 용자에게 열쇠를 완전히 제어할 수 있게 해 준다. 사용자는 개인키의 보안에 전적으로 책임이 있다. 

### 지갑 유형 변형

위 두 지갑 유형은 다양한 방법으로 구현될 수 있다.

**핫월렛**은 인터넷에 연결돼 있어 거래를 생성할 때 키를 쉽게 사용할 수 있다. 자금 이동이 쉽다는 의미다. 

콜드 월렛은 개인키가 완전히 오프라인으로 저장되는 지갑이다. 이것은 조각이나 인터넷과 완전히 분리된 다른 물체에 있을 수 있다. 대형 암호화폐 업체들은 안전한 보관을 위해 자금 대부분을 콜드 월렛에 보관한다.

## 2.10 채굴

### 블록 제너레이터

**왜 채굴이 존재**하는가? 많은 암호화폐는 **작업 증명이라는 합의 알고리즘을 사용하기 때문**에 채굴이 필요하다. 비트코인의 경우 특정 패턴과 일치하는 해시를 만들어서, 퍼즐을 풀기위한 **계산을 수행함으로써 ‘작업’이 ‘증명’**된다. 해시는 완성되면 채굴되는 블록의 주소를 보여준다. 현재 퍼즐이 해결된 후에만 블록체인에 새로운 블록이 추가된다.

**블록을 만드는 작업을 증명하는 과정을 채굴**이라고 한다. (비트코인은 2,116 블록마다 채굴 난이도를 조절하도록 설계돼 있어 시간이 흐르면서 해결하기가 점점 어려워진다.)

## 2.11 합의

합의는 네트워크에 참여한 모든 참가자가 “어떤 블록이 정당한지” 동의하는 과정이다. 블록체인에서 가장 인기 있는 두 가지 합의 방식은 **작업 증명**과 **지분 증명**이다.

### **작업 증명**

- 작업 증명(Proof of Work)은 암호화폐 **트랜잭션을 확인하고** 비트코인 **블록체인에 블록을 넣을 수 있게 한다.**
- 블록체인과 같은 분산 시스템에서 **네트워크의 무결성을 보장하고 악의적인 행위를 방지**하기 위한 합의 알고리즘이다.

풀어서 설명하면, 네트워크의 참여자(채굴자)는 특정한 수학적 문제(해시 퍼즐)를 해결해야 한다. (⇒ 이 과정이 문제 해결)

해결한 문제는  다른 네트워크 참여자들이 빠르게 검증할 수 있어야 하고, 문제를 가장 먼저 푼 채굴자는 새로운 블록을 생성한다. 그리고 이에 대한 보상을 받는다 (⇒ 채굴)

### 블록발견

비트코인 트랜잭션의 새로운 블록은 10분마다 한 마이너에게 확인된다. 네트워크 안에 수천 명의 마이너가 있으므로 네트워크는 어떤 마이너가 새로운 블록을 확인할 권리를 얻는지에 관해 합의를 이끌어 내야 한다.

**마이너가 새로운 블록을 발견하기 위해서**는 먼저 다음을 기준으로 네트워크에서 유효한 것으로 간주되는 **비트코인 블록 해시를 생성**해야 한다.

1. 유효한 블록 헤더의 해시다
2. 결과 블록 해시는 현재 네트워크 목표치보다 낮은 숫자다.

타겟은 항상 유효한 블록 해시보다 높게 유지해야 하는 끊임없이 변화하는 숫자다. 난이도(difficulty)는 유효한 블록 해시를 발견하는 데 필요한 평균 시도 수다. 네트워크 해시 레이트(hash rate)는  네트워크의 마이너들이 유효한 블록 해시를 생성하기 위해 초당 시도하는 횟수다.

비트코인의 초기 매개변수를 설정한 네트워크의 목표는 10분 간격으로 새로운 유효블록을 찾아야 한다는 것이다.  마이너들이 소비하는 처리 능력(컴퓨터 처리 능력 등)을 해시레이트라고 한다. 

비트코인 네트워크의 해시레이트 증가 즉, 유효 블록 해시를 생성하기 위해 더 많은 컴퓨터 처리 능력을 적용하면 네트워크가 블록을 발견하는 데 시간이 줄어든다. 따라서 비트코인 네트워크는 10분마다 평균 1개의 블록이 발견되도록 네트워크 대상을 바꿔 마이너 네트워크가 유효한 블록 해시를 발견하는 것을 다소 어렵게 만든다.

수천 명의 마이너들이 한 블록을 발견하기 위해 훨씬 많은 해시력을 소비하고 있다. 

작업 증명 프로세스 마이너는 새로운 (유효한)블록을 발견하기 위해 아래와 같이 시도한다.

![image](https://github.com/user-attachments/assets/53aa40ec-44b9-4d84-b7d4-0644a7aa14c1)

유효한 블록 해시를 생성하기 위해 마이너는 아래와 같은 정보를 입력해야 한다.

![image](https://github.com/user-attachments/assets/7a687d3f-7f80-4d04-8558-fe75fedf8702)


### 지분 증명

지분 증명(Proof-of-Stake)은 채굴의 필요성을  제거해 작업 증명을 개선하는 것을 목표로 하는 합의 알고리즘이다.

암호화폐 보유자들은 의결권을 얻기 위해 잔고를 걸고, 거래를 검증 하기 위해 네트워크에 의해 선택될 기회를 갖는다. 따라서 스테이킹을 사용하면 노드 또는 벨리데이터 역할을 수행할 수 있다.
